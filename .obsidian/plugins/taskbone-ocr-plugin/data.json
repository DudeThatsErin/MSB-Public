{
  "version": "2.3.0",
  "baseUrl": "https://app.taskbone.com",
  "flowConfigurations": [
    {
      "flow": "https://flows.taskbone.com/cbd24201-6d50-4754-ae53-1320f4f3252b.json",
      "command": {
        "id": "fcba3c0f",
        "name": "OCR active file into annotation file",
        "description": "process the currently selected file and write the extracted text into an annotation file."
      },
      "inputConfigurations": [
        {
          "name": "image",
          "type": "binary/base64",
          "sourceType": "activeFile",
          "isRegularExpression": true,
          "pattern": "\\.(png|jpg|jpeg|gif|pdf|PDF)$",
          "path": ""
        },
        {
          "name": "template",
          "type": "string",
          "sourceType": "constant",
          "value": "---\ndate: \"{{ \"now\" | date: \"%Y-%m-%d %H:%M\" }}\"\ntags: ocr, taskbone\n---\n\n# {{ imageFileBaseName }}\n![[{{ imageFilePath }}]]\n\n{{ text }}\n",
          "path": "taskbone/templates/OCR Template.md"
        }
      ],
      "resultActions": [
        {
          "action": "createOrReplaceFile",
          "sourceType": "property",
          "property": "output",
          "filePath": "${input['image/obsidian/filePath']}.annotations.md"
        }
      ]
    },
    {
      "flow": "https://flows.taskbone.com/cbd24201-6d50-4754-ae53-1320f4f3252b.json",
      "command": {
        "id": "59e3e7d7",
        "name": "OCR image and insert at cursor position",
        "description": "OCR image and insert text at curser position"
      },
      "inputConfigurations": [
        {
          "name": "image",
          "type": "binary/base64",
          "sourceType": "selectFile",
          "isRegularExpression": true,
          "pattern": "\\.(png|jpg|jpeg|gif|pdf|PDF)$",
          "path": ""
        },
        {
          "name": "template",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ text }}",
          "path": "taskbone/templates/OCR Template.md"
        }
      ],
      "resultActions": [
        {
          "action": "insertAtCursorPosition",
          "sourceType": "property",
          "property": "output",
          "filePath": "${input['image/obsidian/filePath']}.annotations.md"
        }
      ]
    },
    {
      "flow": "https://flows.taskbone.com/getMathTextAndFormat.json",
      "command": {
        "id": "6fe4ca7c",
        "name": "OCR Math image and insert at cursor position",
        "description": "OCR Math image and insert text at curser position"
      },
      "inputConfigurations": [
        {
          "name": "image",
          "type": "binary/base64",
          "sourceType": "selectFile",
          "isRegularExpression": true,
          "pattern": "\\.(png|jpg|jpeg|gif)$",
          "path": ""
        },
        {
          "name": "template",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ text }}"
        }
      ],
      "resultActions": [
        {
          "action": "insertAtCursorPosition",
          "sourceType": "property",
          "property": "output"
        }
      ]
    },
    {
      "flow": "https://flows.taskbone.com/48432c07-6063-47aa-b43a-debe483673c0.json",
      "command": {
        "id": "fff10a8a",
        "name": "Sync with Todoist (tasks-style)",
        "description": "Pushes new tasks to Todoist and syncs state in both directions."
      },
      "inputConfigurations": [
        {
          "name": "text",
          "type": "string",
          "sourceType": "activeFile"
        },
        {
          "name": "taskRegex",
          "type": "string",
          "sourceType": "constant",
          "value": "^[ \\t]*(-|\\*|\\d*\\.) \\[[xX ]\\].*$"
        },
        {
          "name": "level",
          "type": "string",
          "sourceType": "constant",
          "value": "{% assign spaces = task | findAll: '(?<=^[\\\\s]*)[\\\\s]+?' %}{{ spaces | size }}"
        },
        {
          "name": "state",
          "type": "string",
          "sourceType": "constant",
          "value": "{% assign x = task | findOne: '\\\\[[xX ]\\\\]' %}{% if x == '[ ]' %}open{% else %}resolved{% endif %}"
        },
        {
          "name": "title",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ task | findOne: '(?<=^[ \\\\t]*- \\\\[[xX ]\\\\] ).*?(?=$|#|üìÖ|‚è≥|üõ´|‚è´|üîº|üîΩ|üîÅ|‚úÖ|(?:\\\\[Todoist\\\\]))' | strip }}"
        },
        {
          "name": "description",
          "type": "string",
          "sourceType": "constant",
          "value": "[Link to Obsidian](obsidian://open?vault={{ vaultName | url_encode }}&file={{ filePath | url_encode}})"
        },
        {
          "name": "projectName",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ task | findOne: '(?<=#project::).*?(?= ?($|#))' }}"
        },
        {
          "name": "labelNames",
          "type": "string",
          "sourceType": "constant",
          "value": "{% assign labels = task | findAll: '(?<=[\\\\t ]*[#])([^\\\\s:#,.])+(?![\\\\S]*::)' %}{{ labels | json }}"
        },
        {
          "name": "dueDate",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ task | findOne: '(?<=(#due::|üìÖ ))\\\\d{4}-\\\\d{2}-\\\\d{2}' }}"
        },
        {
          "name": "todoistId",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ task | findOne: '(?<=https:\\\\/\\\\/todoist.com\\\\/showTask\\\\?id=)\\\\d*' }}"
        },
        {
          "name": "updateTemplate",
          "type": "string",
          "sourceType": "constant",
          "value": "{%- assign tasks = tasks | reverse -%}\n{%- assign update = original -%}\n\n{%- for task in tasks -%}\n\n{%- comment -%}\nThis section checks if a task was added to Todoist for a to-do found in the text. It then adds the link to the task\n{%- endcomment -%}\n\n{%- assign addCommand = task.commands | where: \"type\", \"item_add\" | first -%}\n{%- if addCommand -%}\n\n{%- assign todoistId = idMap[addCommand.temp_id] -%}\n{%- capture updatedLine %}{{ task.text.match | rstrip }} [Todoist](https://todoist.com/showTask?id={{ todoistId }}){% endcapture -%}\n{%- assign length = task.text.match | size -%}\n{%- assign update = update | replaceAtPosition: updatedLine,  task.text.index, length -%}\n\n{%- else -%}\n\n{%- comment -%}\nThis section checks if a task was completed in Todoist and checks it off. The Todoist API is not very friendly in this case. So this is not very straight forward...\n{%- endcomment -%}\n{%- assign todoistId = task.todoist.todoistId -%}\n{%- unless todoistId -%}\n{%- assign length = task.text.match | size -%}\n{%- capture updatedLine %}{{ task.text.match | rstrip | replace_first: \"[ ]\", \"[x]\" }}{% unless task.text.match contains \"‚úÖ\" %} ‚úÖ {{ \"now\" | date: \"%Y-%m-%d\" }}{% endunless %}{% endcapture -%}\n{%- assign update = update | replaceAtPosition: updatedLine,  task.text.index, length -%}\n{%- endunless -%}\n\n{%- endif -%}\n{%- endfor -%}\n{{ update }}",
          "path": "taskbone/templates/formatTasks.md"
        },
        {
          "name": "ignoreFieldsOnUpdate",
          "type": "string",
          "sourceType": "constant",
          "value": "{\n  \"title\": true,\n  \"description\": true,\n  \"labels\": true,\n  \"dueDate\": true,\n  \"project\": true,\n  \"parent\": false,\n  \"state\": false\n}"
        },
        {
          "name": "priority",
          "type": "string",
          "value": "{% if task contains \"‚è´\" %}4{% elsif task contains \"üîº\" %}3{% endif %}",
          "sourceType": "constant"
        }
      ],
      "resultActions": [
        {
          "action": "replaceActiveFile",
          "sourceType": "property",
          "property": "updatedContent"
        }
      ]
    },
    {
      "flow": "https://flows.taskbone.com/c1b21405-7a22-4cdf-9d11-62b3d0a2a1b4.json",
      "command": {
        "id": "b7eb99c6",
        "name": "Import tasks into current daily note",
        "description": "Import Todoist tasks due on the day of the currently active daily note"
      },
      "inputConfigurations": [
        {
          "name": "filter",
          "type": "string",
          "sourceType": "constant",
          "value": "due: {% assign split = fileBaseName | split: '-' %}{{ split[1] }}/{{ split[2] }}/{{ split[0] }}"
        },
        {
          "name": "template",
          "type": "string",
          "sourceType": "constant",
          "value": "{%- for task in tasks %}{% capture line %}\n\n{% for num in (1..task.level)%}    {% endfor %}\n\n- [ ] {{ task.title }}\n\n{% for label in task.labelNames %} #{{ label }}{% endfor %}\n\n [todoist]({{ task.url }})\n\n{% endcapture %}{{ line | strip_newlines}}\n{% endfor %}"
        },
        {
          "name": "fileMetaData",
          "type": "string",
          "sourceType": "activeFile"
        }
      ],
      "resultActions": [
        {
          "action": "insertAtCursorPosition",
          "sourceType": "property",
          "property": "document"
        }
      ],
      "triggers": []
    },
    {
      "flow": "https://flows.taskbone.com/ObsidianTodoistSyncWithFilter.json",
      "command": {
        "id": "b50888f3",
        "name": "Sync project tasks",
        "description": "Sync based on the 'Project' defined in the frontmatter"
      },
      "inputConfigurations": [
        {
          "name": "text",
          "type": "string",
          "sourceType": "activeFile"
        },
        {
          "name": "filter",
          "type": "string",
          "sourceType": "constant",
          "value": "{% if metadata.frontmatter.Project %}#{{ metadata.frontmatter.Project }}{% else %}#Inbox{% endif %}"
        },
        {
          "name": "taskRegex",
          "type": "string",
          "sourceType": "constant",
          "value": "^[ \\t]*(-|\\*|\\d*\\.) \\[[xX ]\\].*$"
        },
        {
          "name": "level",
          "type": "string",
          "sourceType": "constant",
          "value": "{% assign spaces = task | findAll: '(?<=^[\\\\s]*)[\\\\s]+?' %}{{ spaces | size }}"
        },
        {
          "name": "state",
          "type": "string",
          "sourceType": "constant",
          "value": "{% assign x = task | findOne: '\\\\[[xX ]\\\\]' %}{% if x == '[ ]' %}open{% else %}resolved{% endif %}"
        },
        {
          "name": "title",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ task | findOne: '(?<=^[ \\\\t]*- \\\\[[xX ]\\\\] ).*?(?=$|#|üìÖ|‚è≥|üõ´|‚è´|üîº|üîΩ|üîÅ|‚úÖ|(?:\\\\[Todoist\\\\]))' | strip }}"
        },
        {
          "name": "description",
          "type": "string",
          "sourceType": "constant",
          "value": "[Obsidian](obsidian://open?vault={{ vaultName | url_encode }}&file={{ filePath | url_encode}})"
        },
        {
          "name": "projectName",
          "type": "string",
          "sourceType": "constant",
          "value": "{% if metadata.frontmatter.Project %}{{ metadata.frontmatter.Project }}{% else %}Inbox{% endif %}"
        },
        {
          "name": "labelNames",
          "type": "string",
          "sourceType": "constant",
          "value": "{% assign labels = task | findAll: '(?<=[\\\\t ]*[#])([^\\\\s:#,.])+(?![\\\\S]*::)' %}{{ labels | json }}"
        },
        {
          "name": "dueDate",
          "type": "string",
          "sourceType": "constant",
          "value": "{%- assign due = task | findOne: '(?<=(#due::|üìÖ ))\\\\d{4}-\\\\d{2}-\\\\d{2}(T\\\\d{2}:\\\\d{2})?' -%}\n{%- if due -%}\n{{ due }}\n{%- assign length = due | size -%}\n{%- if length ==  16 -%}\n:00\n{%- endif -%}\n{%- endif -%}"
        },
        {
          "name": "priority",
          "type": "string",
          "sourceType": "constant",
          "value": "{% if task contains \"‚è´\" %}4{% elsif task contains \"üîº\" %}3{% endif %}"
        },
        {
          "name": "todoistId",
          "type": "string",
          "sourceType": "constant",
          "value": "{{ task | findOne: '(?<=https:\\\\/\\\\/todoist.com\\\\/showTask\\\\?id=)\\\\d*' }}"
        },
        {
          "name": "updateTemplate",
          "type": "string",
          "sourceType": "constant",
          "value": "{%- assign tasks = tasks | reverse -%}\n\n{%- assign update = original -%}\n\n{%- for task in tasks -%}\n\n{%- comment -%}\nThis section checks if a task was added to Todoist for a to-do found in the text. It then adds the link to the task\n{%- endcomment -%}\n\n{%- assign addCommand = task.commands | where: \"type\", \"item_add\" | first -%}\n{%- if addCommand -%}\n\n{%- assign todoistId = idMap[addCommand.temp_id] -%}\n{%- capture updatedLine %}{{ task.text.match | rstrip }} [Todoist](https://todoist.com/showTask?id={{ todoistId }}){% endcapture -%}\n{%- assign length = task.text.match | size -%}\n{%- assign update = update | replaceAtPosition: updatedLine,  task.text.index, length -%}\n\n{%- else -%}\n\n{%- comment -%}\nThis section checks if a task was completed in Todoist and checks it off. The Todoist API is not very friendly in this case. So this is not very straight forward...\n{%- endcomment -%}\n{%- assign todoistId = task.todoist.todoistId -%}\n{%- unless todoistId -%}\n{%- assign length = task.text.match | size -%}\n{%- capture updatedLine %}{{ task.text.match | rstrip | replace_first: \"[ ]\", \"[x]\" }}{% unless task.text.match contains \"‚úÖ\" %} ‚úÖ {{ \"now\" | date: \"%Y-%m-%d\" }}{% endunless %}{% endcapture -%}\n{%- assign update = update | replaceAtPosition: updatedLine,  task.text.index, length -%}\n{%- endunless -%}\n\n{%- endif -%}\n{%- endfor -%}\n{%- assign taskIds = tasks | JSONPath: \"$..commands..args.id\" | uniq | join: ' ' -%}\n{%- capture newTasks -%}\n{%- for task in matchingTasks -%}\n{%- unless taskIds contains task.entryId %}\n{% capture line %}\n\n{% for num in (1..task.level)%}    {% endfor %}\n\n- [ ] {{ task.title }}\n{% for label in task.labelNames %} #{{ label }}{% endfor %}\n{% if task.dueDate %} üìÖ {{task.dueDate}}{% endif %}\n [Todoist]({{ task.url }})\n\n{% endcapture %}{{ line | strip_newlines}}{%- endunless -%}\n{%- endfor -%}\n{%- endcapture -%}\n{%- assign lastOpenTask = update | findAll: '^[ \\\\t]*(-|\\\\*|\\\\d*\\\\.) \\\\[[ ]\\\\].*', true | last -%}\n{%- if lastOpenTask -%}\n{%- assign length = lastOpenTask.match | size -%}\n{%- assign position = lastOpenTask.index | plus: length -%}\n{%- else -%}\n{%- assign todoCallOut = update | findAll: '^>\\\\s*\\\\[!todo\\\\].*', true | last -%}\n{%- if todoCallOut -%}\n{%- assign length = todoCallOut.match | size -%}\n{%- assign position = todoCallOut.index | plus: length -%}\n{%- else -%}\n{%- assign position = update | size -%}\n{%- endif -%}\n{%- endif -%}\n{{ update | replaceAtPosition: newTasks, position, 0 }}"
        },
        {
          "name": "ignoreFieldsOnUpdate",
          "type": "string",
          "sourceType": "constant",
          "value": "{\n  \"title\": true,\n  \"description\": true,\n  \"labels\": true,\n  \"dueDate\": true,\n  \"project\": true,\n  \"parent\": false,\n  \"state\": false\n}"
        }
      ],
      "resultActions": [
        {
          "action": "replaceActiveFile",
          "sourceType": "property",
          "property": "updatedContent"
        }
      ]
    },
    {
      "flow": "https://flows.taskbone.com/c1b21405-7a22-4cdf-9d11-62b3d0a2a1b4.json",
      "command": {
        "id": "d4c8da80",
        "name": "Import Todoist tasks (tasks-style)",
        "description": "Import Todoist tasks due today or overdue at cursor position"
      },
      "inputConfigurations": [
        {
          "name": "filter",
          "type": "string",
          "sourceType": "constant",
          "value": "(today | overdue)"
        },
        {
          "name": "template",
          "type": "string",
          "sourceType": "constant",
          "value": "{%- for task in tasks %}{% capture line %}\n\n{% for num in (1..task.level)%}    {% endfor %}\n\n- [ ] {{ task.title }}\n\n{% for label in task.labelNames %} #{{ label }}{% endfor %}\n\n{% if task.priority == 4 %} ‚è´{% elsif task.priority == 3 %} üîº{% endif %}\n\n{% if task.dueDate %} üìÖ {{task.dueDate}}{% endif %}\n [Todoist]({{ task.url }})\n\n{% endcapture %}{{ line | strip_newlines}}\n{% endfor %}"
        },
        {
          "name": "fileMetaData",
          "type": "string",
          "value": "",
          "sourceType": "constant",
          "path": ""
        }
      ],
      "resultActions": [
        {
          "action": "insertAtCursorPosition",
          "sourceType": "property",
          "property": "document"
        }
      ]
    }
  ],
  "flowDefinitions": [
    {
      "id": "c1b21405-7a22-4cdf-9d11-62b3d0a2a1b4",
      "name": "Get open items from Todoist",
      "description": "Get open Todoist tasks by filter and format them with a liquid template",
      "url": "https://flows.taskbone.com/c1b21405-7a22-4cdf-9d11-62b3d0a2a1b4.json",
      "inputDefinitions": [
        {
          "name": "filter",
          "mandatory": true,
          "description": "Filter for tasks, supports liquid input.",
          "type": "string"
        },
        {
          "name": "template",
          "type": "string",
          "mandatory": true,
          "description": "The liquid template to format the tasks"
        },
        {
          "name": "fileMetaData",
          "type": "string",
          "mandatory": true,
          "description": "The metadata of this file will be available in the filter and template."
        }
      ],
      "outputDefinitions": [
        {
          "name": "document",
          "description": "The formatted tasks"
        }
      ],
      "steps": [
        {
          "id": "renderFilter",
          "function": "liquid",
          "inputs": {
            "template": "$.input.filter",
            "vaultName": "$.input.fileMetaData/obsidian/vaultName",
            "filePath": "$.input.fileMetaData/obsidian/filePath",
            "metadata": "$.input.fileMetaData/obsidian/metadata",
            "fileBaseName": "$.input.fileMetaData/obsidian/fileBaseName",
            "fileExtension": "$.input.fileMetaData/obsidian/fileExtension",
            "fileParentPath": "$.input.fileMetaData/obsidian/fileParentPath"
          }
        },
        {
          "id": "getTaskListFromTodoist",
          "function": "todoist.getOpenTasks",
          "inputs": {
            "filter": "$.renderFilter.output"
          }
        },
        {
          "id": "mergeData",
          "function": "stepOutputToJsonArray",
          "inputs": {
            "step": "$.getTaskListFromTodoist"
          }
        },
        {
          "id": "flatData",
          "function": "flatten",
          "inputs": {
            "json": "$.mergeData.json"
          }
        },
        {
          "id": "render",
          "function": "liquid",
          "inputs": {
            "tasks": "$.flatData.json",
            "template": "$.input.template",
            "vaultName": "$.input.fileMetaData/obsidian/vaultName",
            "metadataContent": "$.input.fileMetaData",
            "filePath": "$.input.fileMetaData/obsidian/filePath",
            "metadata": "$.input.fileMetaData/obsidian/metadata",
            "fileBaseName": "$.input.fileMetaData/obsidian/fileBaseName",
            "fileExtension": "$.input.fileMetaData/obsidian/fileExtension",
            "fileParentPath": "$.input.fileMetaData/obsidian/fileParentPath"
          }
        },
        {
          "id": "output",
          "function": "output",
          "inputs": {
            "document": "$.render.output"
          }
        }
      ]
    },
    {
      "id": "48432c07-6063-47aa-b43a-debe483673c0",
      "name": "Create Todoist tasks and sync state",
      "description": "Pushes new tasks to Todoist and syncs state in both directions.",
      "url": "https://flows.taskbone.com/48432c07-6063-47aa-b43a-debe483673c0.json",
      "inputDefinitions": [
        {
          "name": "text",
          "mandatory": true,
          "description": "The markdown text/liquid template to analyze for tasks",
          "type": "string"
        },
        {
          "name": "taskRegex",
          "mandatory": true,
          "description": "Match the text that defines one task",
          "type": "string"
        },
        {
          "name": "level",
          "mandatory": true,
          "description": "The indentation level of the task",
          "type": "string"
        },
        {
          "name": "state",
          "mandatory": true,
          "description": "The state of the task. has to be 'open' or 'resolved'.",
          "type": "string"
        },
        {
          "name": "title",
          "mandatory": true,
          "description": "The title of the task",
          "type": "string"
        },
        {
          "name": "description",
          "mandatory": true,
          "description": "The description of the task",
          "type": "string"
        },
        {
          "name": "projectName",
          "mandatory": true,
          "description": "The project name of the task",
          "type": "string"
        },
        {
          "name": "labelNames",
          "mandatory": true,
          "description": "JSON string array of labels",
          "type": "string"
        },
        {
          "name": "dueDate",
          "mandatory": true,
          "description": "The dueDate of the task in yyyy-MM-dd",
          "type": "string"
        },
        {
          "name": "priority",
          "mandatory": true,
          "description": "The priority of the task. Can be 1, 2, 3, or 4",
          "type": "string"
        },
        {
          "name": "todoistId",
          "mandatory": true,
          "description": "The id of the task in Todoist",
          "type": "string"
        },
        {
          "name": "updateTemplate",
          "type": "string",
          "mandatory": true,
          "description": "Liquid template for updated content."
        },
        {
          "name": "ignoreFieldsOnUpdate",
          "type": "string",
          "mandatory": true,
          "description": "Which fields should NOT be overwritten from Obsidian for existing tasks in Todoist. JSON object with \n IgnoreFieldsOnUpdate {\n  title?: boolean,\n  description?: boolean,\n  labels?: boolean,\n  dueDate?: boolean,\n  project?: boolean,\n  parent?: boolean,\n  state?: boolean\n. Can be liquid.}"
        }
      ],
      "outputDefinitions": [
        {
          "name": "updatedContent",
          "description": "Updated content"
        }
      ],
      "steps": [
        {
          "id": "renderText",
          "function": "liquid",
          "inputs": {
            "template": "$.input.text",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata"
          }
        },
        {
          "id": "tasks",
          "function": "findAll",
          "inputs": {
            "matchString": "$.input.taskRegex",
            "stringIsRegex": true,
            "content": "$.renderText.output"
          }
        },
        {
          "id": "level",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "taskIndex": "$.tasks.index",
            "text": "$.renderText.output",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "template": "$.input.level"
          }
        },
        {
          "id": "levelNumber",
          "function": "stringToNumber",
          "inputs": {
            "level": "$.level.output"
          }
        },
        {
          "id": "state",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "template": "$.input.state"
          }
        },
        {
          "id": "title",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "baseName": "$.input.text/obsidian/fileBaseName",
            "template": "$.input.title"
          }
        },
        {
          "id": "dueDate",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "template": "$.input.dueDate"
          }
        },
        {
          "id": "todoistId",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "template": "$.input.todoistId"
          }
        },
        {
          "id": "labelNames",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "template": "$.input.labelNames"
          }
        },
        {
          "id": "projectName",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "taskIndex": "$.tasks.index",
            "text": "$.renderText.output",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "baseName": "$.input.text/obsidian/fileBaseName",
            "template": "$.input.projectName"
          }
        },
        {
          "id": "description",
          "function": "liquid",
          "inputs": {
            "text": "$.renderText.output",
            "task": "$.tasks.match",
            "taskIndex": "$.tasks.index",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "baseName": "$.input.text/obsidian/fileBaseName",
            "template": "$.input.description"
          }
        },
        {
          "id": "priority",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "baseName": "$.input.text/obsidian/fileBaseName",
            "template": "$.input.priority"
          }
        },
        {
          "id": "ignoreFieldsOnUpdate",
          "function": "liquid",
          "inputs": {
            "task": "$.tasks.match",
            "vaultName": "$.input.text/obsidian/vaultName",
            "filePath": "$.input.text/obsidian/filePath",
            "metadata": "$.input.text/obsidian/metadata",
            "template": "$.input.ignoreFieldsOnUpdate"
          }
        },
        {
          "id": "commands",
          "function": "todoist.createCommandsFromDeltaList",
          "inputs": {
            "type": "delta",
            "title": "$.title.output",
            "resolutionState": "$.state.output",
            "level": "$.levelNumber.level",
            "dueDate": "$.dueDate.output",
            "todoistId": "$.todoistId.output",
            "labelNames": "$.labelNames.output",
            "projectName": "$.projectName.output",
            "content": "$.description.output",
            "priority": "$.priority.output",
            "ignoreFieldsOnUpdate": "$.ignoreFieldsOnUpdate.output"
          }
        },
        {
          "id": "allCommands",
          "function": "outputToJsonArray",
          "inputs": {
            "input": "$.commands.command",
            "ignoreDividers": true
          }
        },
        {
          "id": "sync",
          "function": "todoist.sync",
          "inputs": {
            "commands": "$.allCommands.json"
          }
        },
        {
          "id": "todoistTasks",
          "function": "todoist.getTasksById",
          "inputs": {
            "id": "$.todoistId.output"
          }
        },
        {
          "id": "todoistTasksJSON",
          "function": "stepOutputToJson",
          "inputs": {
            "step": "$.todoistTasks"
          }
        },
        {
          "id": "tasksJSON",
          "function": "stepOutputToJson",
          "inputs": {
            "step": "$.tasks"
          }
        },
        {
          "id": "commandArray",
          "function": "outputToJsonArray",
          "inputs": {
            "input": "$.commands.command",
            "ignoreDividers": false
          }
        },
        {
          "id": "flatCommandArray",
          "function": "flatten",
          "inputs": {
            "json": "$.commandArray.json"
          }
        },
        {
          "id": "combineTasksAndTodoist",
          "function": "output",
          "inputs": {
            "todoist": "$.todoistTasksJSON.json",
            "text": "$.tasksJSON.json",
            "commands": "$.flatCommandArray.json"
          }
        },
        {
          "id": "combineTasksAndTodoistArray",
          "function": "stepOutputToJsonArray",
          "inputs": {
            "step": "$.combineTasksAndTodoist"
          }
        },
        {
          "id": "updateContent",
          "function": "liquid",
          "inputs": {
            "template": "$.input.updateTemplate",
            "original": "$.renderText.output",
            "tasks": "$.combineTasksAndTodoistArray.json",
            "idMap": "$.sync.tempIdMapping"
          }
        },
        {
          "id": "output",
          "function": "output",
          "inputs": {
            "updatedContent": "$.updateContent.output"
          }
        }
      ]
    }
  ],
  "apiKey": "KohlCtkaVn2Ld/Or8UrBSWoc"
}