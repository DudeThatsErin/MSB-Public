/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.js
var import_obsidian3 = require("obsidian");

// src/settings.js
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiProvider: "all",
  pexelsApiKey: "",
  pixabayApiKey: "",
  flickrApiKey: "",
  unsplashApiKey: "",
  imageSize: "medium",
  imageOrientation: "landscape",
  numberOfImages: 10,
  defaultKeywords: "nature, abstract, landscape, technology, art, cityscape, wildlife, ocean, mountains, forest, space, architecture, food, travel, science, music, sports, fashion, business, education, health, culture, history, weather, transportation, industry, people, animals, plants, patterns",
  yPosition: 50,
  xPosition: 50,
  customBannerField: ["banner"],
  customYPositionField: ["banner-y"],
  customXPositionField: ["banner-x"],
  customContentStartField: ["content-start"],
  customImageDisplayField: ["banner-display"],
  customImageRepeatField: ["banner-repeat"],
  customBannerHeightField: ["banner-height"],
  customFadeField: ["banner-fade"],
  customBorderRadiusField: ["banner-radius"],
  customTitleColorField: ["banner-inline-title-color"],
  customBannerShuffleField: ["banner-shuffle"],
  folderImages: [],
  contentStartPosition: 150,
  imageDisplay: "cover",
  imageRepeat: false,
  bannerHeight: 350,
  fade: -75,
  borderRadius: 17,
  showPinIcon: true,
  pinnedImageFolder: "pixel-banner-images",
  showReleaseNotes: true,
  lastVersion: null,
  showRefreshIcon: true,
  showViewImageIcon: false,
  hidePixelBannerFields: false,
  hidePropertiesSectionIfOnlyBanner: false,
  titleColor: "var(--inline-title-color)",
  enableImageShuffle: false,
  hideEmbeddedNoteTitles: false,
  hideEmbeddedNoteBanners: false,
  showSelectImageIcon: true,
  defaultSelectImagePath: "",
  useShortPath: true,
  bannerGap: 12
};
var FolderSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, onChoose) {
    super(app2);
    this.onChoose = onChoose;
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
};
var FolderImageSetting = class extends import_obsidian.Setting {
  constructor(containerEl, plugin, folderImage, index, onDelete) {
    super(containerEl);
    this.plugin = plugin;
    this.folderImage = folderImage;
    this.index = index;
    this.onDelete = onDelete;
    this.setClass("folder-image-setting");
    this.settingEl.empty();
    const folderImageDeleteContainer = this.settingEl.createDiv("folder-image-delete-container");
    this.addDeleteButton(folderImageDeleteContainer);
    const infoEl = this.settingEl.createDiv("setting-item-info");
    infoEl.createDiv("setting-item-name");
    infoEl.createDiv("setting-item-description");
    this.addFolderInput();
    this.addImageInput();
    this.addImageDisplaySettings();
    this.addYPostionAndContentStart();
    this.addFadeAndBannerHeight();
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addContentStartInput(controlEl);
    this.addBorderRadiusInput(controlEl);
    const controlEl2 = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addColorSettings(controlEl2);
    this.addDirectChildrenOnlyToggle();
  }
  addDeleteButton(containerEl) {
    const deleteButton = containerEl.createEl("button", { cls: "pixel-banner-setting--delete-button" });
    deleteButton.style.marginLeft = "20px";
    deleteButton.style.width = "30px";
    deleteButton.style.height = "30px";
    deleteButton.style.padding = "0";
    deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-trash-2"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
    deleteButton.addEventListener("click", async () => {
      this.plugin.settings.folderImages.splice(this.index, 1);
      await this.plugin.saveSettings();
      this.settingEl.remove();
      if (this.onDelete) {
        this.onDelete();
      }
    });
  }
  addFolderInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const folderInput = new import_obsidian.Setting(folderInputContainer).setName("Folder Path").addText((text) => {
      text.setValue(this.folderImage.folder || "").onChange(async (value) => {
        this.folderImage.folder = value;
        await this.plugin.saveSettings();
      });
      this.folderInputEl = text.inputEl;
      this.folderInputEl.style.width = "300px";
    });
    folderInput.addButton((button) => button.setButtonText("Browse").onClick(() => {
      new FolderSuggestModal(this.plugin.app, (chosenPath) => {
        this.folderImage.folder = chosenPath;
        this.folderInputEl.value = chosenPath;
        this.plugin.saveSettings();
      }).open();
    }));
    const shuffleContainer = this.settingEl.createDiv("shuffle-container");
    const shuffleToggle = new import_obsidian.Setting(shuffleContainer).setName("Enable Image Shuffle").setDesc("Randomly select an image from a specified folder each time the note loads").addToggle((toggle) => {
      toggle.setValue(this.folderImage.enableImageShuffle || false).onChange(async (value) => {
        this.folderImage.enableImageShuffle = value;
        if (value) {
          shuffleFolderInput.settingEl.style.display = "flex";
          this.imageInputContainer.style.display = "none";
        } else {
          shuffleFolderInput.settingEl.style.display = "none";
          this.imageInputContainer.style.display = "block";
        }
        await this.plugin.saveSettings();
      });
    });
    const shuffleFolderInput = new import_obsidian.Setting(shuffleContainer).setName("Image Shuffle Folder").setDesc("Folder containing images to randomly select from").addText((text) => {
      text.setValue(this.folderImage.shuffleFolder || "").onChange(async (value) => {
        this.folderImage.shuffleFolder = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "300px";
    });
    shuffleFolderInput.addButton((button) => button.setButtonText("Browse").onClick(() => {
      new FolderSuggestModal(this.plugin.app, (chosenPath) => {
        this.folderImage.shuffleFolder = chosenPath;
        shuffleFolderInput.controlEl.querySelector("input").value = chosenPath;
        this.plugin.saveSettings();
      }).open();
    }));
    if (!this.folderImage.enableImageShuffle) {
      shuffleFolderInput.settingEl.style.display = "none";
    }
  }
  addImageInput() {
    this.imageInputContainer = this.settingEl.createDiv("folder-input-container");
    if (this.folderImage.enableImageShuffle) {
      this.imageInputContainer.style.display = "none";
    }
    const imageInput = new import_obsidian.Setting(this.imageInputContainer).setName("Image URL or Keyword").addText((text) => {
      text.setValue(this.folderImage.image || "").onChange(async (value) => {
        this.folderImage.image = value;
        await this.plugin.saveSettings();
      });
      this.imageInputEl = text.inputEl;
      this.imageInputEl.style.width = "306px";
    });
  }
  addImageDisplaySettings(containerEl) {
    const displayContainer = this.settingEl.createDiv("display-and-repeat-container");
    const displaySetting = new import_obsidian.Setting(displayContainer).setName("Image Display").addDropdown((dropdown) => {
      dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.folderImage.imageDisplay || "cover").onChange(async (value) => {
        this.folderImage.imageDisplay = value;
        await this.plugin.saveSettings();
      });
      dropdown.selectEl.style.marginRight = "20px";
    });
    const repeatSetting = new import_obsidian.Setting(displayContainer).setName("repeat").addToggle((toggle) => {
      toggle.setValue(this.folderImage.imageRepeat || false).onChange(async (value) => {
        this.folderImage.imageRepeat = value;
        await this.plugin.saveSettings();
      });
    });
    const toggleEl = repeatSetting.controlEl.querySelector(".checkbox-container");
    if (toggleEl) toggleEl.style.justifyContent = "flex-start";
  }
  addYPostionAndContentStart() {
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addYPositionInput(controlEl);
    this.addXPositionInput(controlEl);
  }
  addFadeAndBannerHeight() {
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addFadeInput(controlEl);
    this.addBannerHeightInput(controlEl);
  }
  addYPositionInput(containerEl) {
    const label = containerEl.createEl("label", { text: "Y-Position", cls: "setting-item-name__label" });
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "0",
        max: "100",
        step: "1"
      }
    });
    slider.value = this.folderImage.yPosition || "50";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.yPosition = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  addXPositionInput(containerEl) {
    const label = containerEl.createEl("label", { text: "X-Position", cls: "setting-item-name__label" });
    label.style.marginLeft = "20px";
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "0",
        max: "100",
        step: "1"
      }
    });
    slider.value = this.folderImage.xPosition || "50";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.xPosition = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  addBannerHeightInput(containerEl) {
    const label = containerEl.createEl("label", { text: "Banner Height", cls: "setting-item-name__label" });
    label.style.marginLeft = "20px";
    const heightInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "100",
        max: "2500"
      }
    });
    heightInput.style.width = "50px";
    heightInput.style.marginLeft = "10px";
    heightInput.value = this.folderImage.bannerHeight || "";
    heightInput.placeholder = String(this.plugin.settings.bannerHeight || 350);
    heightInput.addEventListener("change", async () => {
      let value = heightInput.value ? parseInt(heightInput.value) : null;
      if (value !== null) {
        value = Math.max(100, Math.min(2500, value));
        this.folderImage.bannerHeight = value;
        heightInput.value = value;
      } else {
        delete this.folderImage.bannerHeight;
        heightInput.value = "";
      }
      await this.plugin.saveSettings();
    });
    label.appendChild(heightInput);
    containerEl.appendChild(label);
  }
  addFadeInput(containerEl) {
    const label = containerEl.createEl("label", { text: "Fade", cls: "setting-item-name__label" });
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "-1500",
        max: "100",
        step: "5"
      }
    });
    slider.value = this.folderImage.fade !== void 0 ? this.folderImage.fade : "-75";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.fade = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  addColorSettings(containerEl) {
    const colorContainer = containerEl.createDiv("color-settings-container");
    new import_obsidian.Setting(colorContainer).setName("Inline Title Color").addColorPicker((color) => color.setValue((() => {
      const currentColor = this.folderImage.titleColor || this.plugin.settings.titleColor;
      if (currentColor.startsWith("var(--")) {
        const temp = document.createElement("div");
        temp.style.color = currentColor;
        document.body.appendChild(temp);
        const computedColor = getComputedStyle(temp).color;
        document.body.removeChild(temp);
        const rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          const [_, r, g, b] = rgbMatch;
          const hexColor = "#" + parseInt(r).toString(16).padStart(2, "0") + parseInt(g).toString(16).padStart(2, "0") + parseInt(b).toString(16).padStart(2, "0");
          return hexColor;
        }
        return "#000000";
      }
      return currentColor;
    })()).onChange(async (value) => {
      this.folderImage.titleColor = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.folderImage.titleColor = this.plugin.settings.titleColor;
      await this.plugin.saveSettings();
      const colorPickerEl = button.extraSettingsEl.parentElement.querySelector('input[type="color"]');
      if (colorPickerEl) {
        const currentColor = this.plugin.settings.titleColor;
        if (currentColor.startsWith("var(--")) {
          const temp = document.createElement("div");
          temp.style.color = currentColor;
          document.body.appendChild(temp);
          const computedColor = getComputedStyle(temp).color;
          document.body.removeChild(temp);
          const rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (rgbMatch) {
            const [_, r, g, b] = rgbMatch;
            const hexColor = "#" + parseInt(r).toString(16).padStart(2, "0") + parseInt(g).toString(16).padStart(2, "0") + parseInt(b).toString(16).padStart(2, "0");
            colorPickerEl.value = hexColor;
          }
        } else {
          colorPickerEl.value = currentColor;
        }
      }
    }));
  }
  addDirectChildrenOnlyToggle() {
    new import_obsidian.Setting(this.settingEl).setName("Direct Children Only").setDesc("Apply banner only to direct children of the folder").addToggle((toggle) => {
      toggle.setValue(this.folderImage.directChildrenOnly || false).onChange(async (value) => {
        this.folderImage.directChildrenOnly = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addContentStartInput(containerEl) {
    const label = containerEl.createEl("label", { text: "Content Start", cls: "setting-item-name__label" });
    label.style.marginRight = "20px";
    const contentStartInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0"
      }
    });
    contentStartInput.style.width = "50px";
    contentStartInput.style.marginLeft = "10px";
    contentStartInput.value = this.folderImage.contentStartPosition || "150";
    contentStartInput.addEventListener("change", async () => {
      this.folderImage.contentStartPosition = parseInt(contentStartInput.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(contentStartInput);
    containerEl.appendChild(label);
  }
  addBorderRadiusInput(containerEl) {
    var _a;
    const label = containerEl.createEl("label", { text: "Border Radius", cls: "setting-item-name__label" });
    const radiusInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0",
        max: "50"
      }
    });
    radiusInput.style.width = "50px";
    radiusInput.style.marginLeft = "10px";
    radiusInput.value = (_a = this.folderImage.borderRadius) != null ? _a : "";
    radiusInput.placeholder = String(this.plugin.settings.borderRadius || 17);
    radiusInput.addEventListener("change", async () => {
      let value = radiusInput.value ? parseInt(radiusInput.value) : null;
      if (value !== null) {
        value = Math.max(0, Math.min(50, value));
        this.folderImage.borderRadius = value;
        radiusInput.value = String(value);
      } else {
        delete this.folderImage.borderRadius;
        radiusInput.value = "";
      }
      await this.plugin.saveSettings();
    });
    label.appendChild(radiusInput);
    containerEl.appendChild(label);
  }
};
function arrayToString(arr) {
  return Array.isArray(arr) ? arr.join(", ") : arr;
}
function stringToArray(str) {
  return str.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
}
function validateFieldNames(settings, allFields, currentField, newNames) {
  const validNamePattern = /^[a-zA-Z0-9_-]+$/;
  const invalidNames = newNames.filter((name) => !validNamePattern.test(name));
  if (invalidNames.length > 0) {
    return {
      isValid: false,
      message: `Invalid characters in field names (only letters, numbers, dashes, and underscores allowed): ${invalidNames.join(", ")}`
    };
  }
  const otherFields = allFields.filter((f) => f !== currentField);
  const otherFieldNames = otherFields.flatMap((f) => settings[f]);
  const duplicates = newNames.filter((name) => otherFieldNames.includes(name));
  if (duplicates.length > 0) {
    return {
      isValid: false,
      message: `Duplicate field names found: ${duplicates.join(", ")}`
    };
  }
  return { isValid: true };
}
var PixelBannerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("pixel-banner-settings");
    const mainContent = containerEl.createEl("div", { cls: "pixel-banner-main-content" });
    const { tabsEl, tabContentContainer } = this.createTabs(mainContent, [
      "General",
      "Custom Field Names",
      "API Settings",
      "Folder Images",
      "Examples"
    ]);
    const generalTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "General" } });
    this.createGeneralSettings(generalTab);
    const customFieldsTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Custom Field Names" } });
    this.createCustomFieldsSettings(customFieldsTab);
    const apiTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "API Settings" } });
    this.createAPISettings(apiTab);
    const foldersTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Folder Images" } });
    this.createFolderSettings(foldersTab);
    const examplesTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Examples" } });
    this.createExampleSettings(examplesTab);
    tabsEl.firstChild.click();
  }
  createTabs(containerEl, tabNames) {
    const tabsEl = containerEl.createEl("div", { cls: "pixel-banner-settings-tabs" });
    const tabContentContainer = containerEl.createEl("div", { cls: "pixel-banner-settings-tab-content-container" });
    tabNames.forEach((tabName) => {
      const tabEl = tabsEl.createEl("button", { cls: "pixel-banner-settings-tab", text: tabName });
      tabEl.addEventListener("click", () => {
        tabsEl.querySelectorAll(".pixel-banner-settings-tab").forEach((tab) => tab.removeClass("active"));
        tabContentContainer.querySelectorAll(".tab-content").forEach((content) => content.style.display = "none");
        tabEl.addClass("active");
        tabContentContainer.querySelector(`.tab-content[data-tab="${tabName}"]`).style.display = "flex";
      });
    });
    return { tabsEl, tabContentContainer };
  }
  createAPISettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Optionally select which API provider to use for fetching images. See the Examples tab for more information on referencing images by URL or local image. You can use any combination of API keyword, URL, or local image between notes." });
    new import_obsidian.Setting(containerEl).setName("API Provider").setDesc("Select the API provider for fetching images").addDropdown((dropdown) => dropdown.addOption("all", "All (Random)").addOption("pexels", "Pexels").addOption("pixabay", "Pixabay").addOption("flickr", "Flickr").addOption("unsplash", "Unsplash").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
      this.plugin.settings.apiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Pexels API Key");
    containerEl.createEl("span", { text: "Enter your Pexels API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://www.pexels.com/api/", text: "Pexels API" });
    const pexelsApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Pexels API key").setValue(this.plugin.settings.pexelsApiKey).onChange(async (value) => {
        this.plugin.settings.pexelsApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.pexelsApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testPexelsApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Pexels API key is valid!" : "\u274C Invalid Pexels API key");
    }));
    pexelsApiKeySetting.settingEl.style.width = "100%";
    new import_obsidian.Setting(containerEl).setName("Pixabay API Key");
    containerEl.createEl("span", { text: "Enter your Pixabay API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://pixabay.com/api/docs/", text: "Pixabay API" });
    const pixabayApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Pixabay API key").setValue(this.plugin.settings.pixabayApiKey).onChange(async (value) => {
        this.plugin.settings.pixabayApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.pixabayApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testPixabayApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Pixabay API key is valid!" : "\u274C Invalid Pixabay API key");
    }));
    pixabayApiKeySetting.settingEl.style.width = "100%";
    new import_obsidian.Setting(containerEl).setName("Flickr API Key");
    containerEl.createEl("span", { text: "Enter your Flickr API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://www.flickr.com/services/api/", text: "Flickr API" });
    const flickrApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Flickr API key").setValue(this.plugin.settings.flickrApiKey).onChange(async (value) => {
        this.plugin.settings.flickrApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.flickrApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testFlickrApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Flickr API key is valid!" : "\u274C Invalid Flickr API key");
    }));
    new import_obsidian.Setting(containerEl).setName("Unsplash API Key");
    containerEl.createEl("span", { text: "Enter your Unsplash API key (Access Key). Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://unsplash.com/oauth/applications", text: "Unsplash API" });
    const unsplashApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Unsplash API key").setValue(this.plugin.settings.unsplashApiKey).onChange(async (value) => {
        this.plugin.settings.unsplashApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.unsplashApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testUnsplashApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Unsplash API key is valid!" : "\u274C Invalid Unsplash API key");
    }));
    new import_obsidian.Setting(containerEl).setName("Images").setDesc("Configure settings for images fetched from API. These settings apply when using keywords to fetch random images.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Show Pin Icon").setDesc("Show a pin icon on random banner images that allows saving them to your vault. Once pinned, your frontmatter will be updated to use the local image instead of the API image.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPinIcon).onChange(async (value) => {
      this.plugin.settings.showPinIcon = value;
      folderInputSetting.settingEl.style.display = value ? "flex" : "none";
      refreshIconSetting.settingEl.style.display = value ? "flex" : "none";
      await this.plugin.saveSettings();
    }));
    const folderInputSetting = new import_obsidian.Setting(containerEl).setName("Pinned Images Folder").setDesc("Default folder where pinned banner images will be saved").addText((text) => {
      text.setPlaceholder("pixel-banner-images").setValue(this.plugin.settings.pinnedImageFolder).onChange(async (value) => {
        this.plugin.settings.pinnedImageFolder = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async (event) => {
        let value = text.inputEl.value.trim();
        if (!value) {
          value = "pixel-banner-images";
        }
        text.setValue(value);
        this.plugin.settings.pinnedImageFolder = value;
        await this.plugin.saveSettings();
      });
      return text;
    }).addButton((button) => button.setButtonText("Clean Orphaned Pins").setTooltip("Remove pinned images from the default folder that are no longer referenced in Notes").onClick(async () => {
      button.setButtonText("\u{1FAE7} Cleaning...");
      button.setDisabled(true);
      try {
        const result = await this.plugin.cleanOrphanedPins();
        new Notice(`\u{1F9FC} Cleaned ${result.cleaned} orphaned pinned images`);
      } catch (error) {
        console.error("Error cleaning orphaned pins:", error);
        new Notice("Failed to clean orphaned pins");
      } finally {
        button.setButtonText("Clean Orphaned Pins");
        button.setDisabled(false);
      }
    }));
    const refreshIconSetting = new import_obsidian.Setting(containerEl).setName("Show Refresh Icon").setDesc("Show a refresh icon next to the pin icon to get a new random image").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRefreshIcon).onChange(async (value) => {
      this.plugin.settings.showRefreshIcon = value;
      await this.plugin.saveSettings();
    }));
    folderInputSetting.settingEl.style.display = this.plugin.settings.showPinIcon ? "flex" : "none";
    refreshIconSetting.settingEl.style.display = this.plugin.settings.showPinIcon ? "flex" : "none";
    new import_obsidian.Setting(containerEl).setName("Size").setDesc("Select the size of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.imageSize).onChange(async (value) => {
      this.plugin.settings.imageSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Orientation").setDesc("Select the orientation of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("landscape", "Landscape").addOption("portrait", "Portrait").addOption("square", "Square").setValue(this.plugin.settings.imageOrientation).onChange(async (value) => {
      this.plugin.settings.imageOrientation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Number of images").setDesc("Enter the number of random images to fetch (3-50) - (API only)").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.numberOfImages || 10)).onChange(async (value) => {
      let numValue = Number(value);
      if (!isNaN(numValue)) {
        numValue = Math.max(3, Math.min(numValue, 50));
        this.plugin.settings.numberOfImages = numValue;
        await this.plugin.saveSettings();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "3";
      inputEl.max = "50";
      inputEl.style.width = "50px";
    });
    const defaultKeywordsSetting = new import_obsidian.Setting(containerEl).setName("Default keywords").setDesc("Enter a comma-separated list of default keywords to be used when no keyword is provided in the frontmatter, or when the provided keyword does not return any results. - (API only)").addTextArea((text) => {
      text.setPlaceholder("Enter keywords, separated by commas").setValue(this.plugin.settings.defaultKeywords).onChange(async (value) => {
        this.plugin.settings.defaultKeywords = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "100%";
      text.inputEl.style.marginTop = "15px";
      text.inputEl.style.height = "90px";
    }).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.defaultKeywords = DEFAULT_SETTINGS.defaultKeywords;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    defaultKeywordsSetting.settingEl.dataset.id = "defaultKeywords";
    defaultKeywordsSetting.settingEl.style.display = "flex";
    defaultKeywordsSetting.settingEl.style.flexDirection = "column";
  }
  createGeneralSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Configure default settings for all notes. These can be overridden per folder or per note." });
    new import_obsidian.Setting(containerEl).setName("Image Vertical Position").setDesc("Set the vertical position of the image (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.yPosition).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.yPosition = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.yPosition = DEFAULT_SETTINGS.yPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.yPosition;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Image Horizontal Position").setDesc("Set the horizontal position of the image (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.xPosition).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.xPosition = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.xPosition = DEFAULT_SETTINGS.xPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.xPosition;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Content Start Position").setDesc("Set the default vertical position where the content starts (in pixels)").addText((text) => text.setPlaceholder("150").setValue(String(this.plugin.settings.contentStartPosition)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.plugin.settings.contentStartPosition = numValue;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "0";
      inputEl.style.width = "60px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.contentStartPosition = DEFAULT_SETTINGS.contentStartPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.contentStartPosition;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Image Display").setDesc("Set how the banner image should be displayed").addDropdown((dropdown) => {
      dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.plugin.settings.imageDisplay || "cover").onChange(async (value) => {
        this.plugin.settings.imageDisplay = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      return dropdown;
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.imageDisplay = DEFAULT_SETTINGS.imageDisplay;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const dropdownEl = button.extraSettingsEl.parentElement.querySelector("select");
      dropdownEl.value = DEFAULT_SETTINGS.imageDisplay;
      dropdownEl.dispatchEvent(new Event("change"));
    }));
    new import_obsidian.Setting(containerEl).setName("Image Repeat").setDesc('Enable image repetition when "Contain" is selected').addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.imageRepeat).onChange(async (value) => {
        this.plugin.settings.imageRepeat = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      return toggle;
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.imageRepeat = DEFAULT_SETTINGS.imageRepeat;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const checkboxContainer = button.extraSettingsEl.parentElement.querySelector(".checkbox-container");
      const toggleEl = checkboxContainer.querySelector("input");
      if (toggleEl) {
        toggleEl.checked = DEFAULT_SETTINGS.imageRepeat;
        checkboxContainer.classList.toggle("is-enabled", DEFAULT_SETTINGS.imageRepeat);
        const event = new Event("change", { bubbles: true });
        toggleEl.dispatchEvent(event);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Banner Height").setDesc("Set the default height of the banner image (100-2500 pixels)").addText((text) => {
      text.setPlaceholder("350").setValue(String(this.plugin.settings.bannerHeight)).onChange(async (value) => {
        if (value === "" || !isNaN(Number(value))) {
          await this.plugin.saveSettings();
        }
      });
      text.inputEl.addEventListener("blur", async (event) => {
        let numValue = Number(event.target.value);
        if (isNaN(numValue) || event.target.value === "") {
          numValue = 350;
        } else {
          numValue = Math.max(100, Math.min(2500, numValue));
        }
        this.plugin.settings.bannerHeight = numValue;
        text.setValue(String(numValue));
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      text.inputEl.type = "number";
      text.inputEl.min = "100";
      text.inputEl.max = "2500";
      text.inputEl.style.width = "50px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.bannerHeight = DEFAULT_SETTINGS.bannerHeight;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.bannerHeight;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Banner Fade").setDesc("Set the default fade effect for the banner image (-1500 to 100)").addSlider(
      (slider) => slider.setLimits(-1500, 100, 5).setValue(this.plugin.settings.fade).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fade = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.fade = DEFAULT_SETTINGS.fade;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.fade;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Border Radius").setDesc("Set the default border radius of the banner image (0-50 pixels)").addText((text) => {
      text.setPlaceholder("17").setValue(String(this.plugin.settings.borderRadius)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue)) {
          this.plugin.settings.borderRadius = Math.max(0, Math.min(50, numValue));
          await this.plugin.saveSettings();
          this.plugin.updateAllBanners();
        }
      });
      text.inputEl.type = "number";
      text.inputEl.min = "0";
      text.inputEl.max = "50";
      text.inputEl.style.width = "50px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.borderRadius = DEFAULT_SETTINGS.borderRadius;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.borderRadius;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Banner Gap").setDesc("Set the gap between the banner and the window edges (0-50 pixels)").addSlider(
      (slider) => slider.setLimits(0, 50, 1).setValue(this.plugin.settings.bannerGap).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.bannerGap = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.bannerGap = DEFAULT_SETTINGS.bannerGap;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.bannerGap;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Inline Title Color").setDesc("Set the default inline title color for all banners").addColorPicker((color) => color.setValue((() => {
      const currentColor = this.plugin.settings.titleColor;
      if (currentColor.startsWith("var(--")) {
        const temp = document.createElement("div");
        temp.style.color = currentColor;
        document.body.appendChild(temp);
        const computedColor = getComputedStyle(temp).color;
        document.body.removeChild(temp);
        const rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          const [_, r, g, b] = rgbMatch;
          const hexColor = "#" + parseInt(r).toString(16).padStart(2, "0") + parseInt(g).toString(16).padStart(2, "0") + parseInt(b).toString(16).padStart(2, "0");
          return hexColor;
        }
        return "#000000";
      }
      return currentColor;
    })()).onChange(async (value) => {
      this.plugin.settings.titleColor = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.titleColor = DEFAULT_SETTINGS.titleColor;
      await this.plugin.saveSettings();
      const colorPickerEl = button.extraSettingsEl.parentElement.querySelector('input[type="color"]');
      if (colorPickerEl) {
        const temp = document.createElement("div");
        temp.style.color = DEFAULT_SETTINGS.titleColor;
        document.body.appendChild(temp);
        const computedColor = getComputedStyle(temp).color;
        document.body.removeChild(temp);
        const rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          const [_, r, g, b] = rgbMatch;
          const hexColor = "#" + parseInt(r).toString(16).padStart(2, "0") + parseInt(g).toString(16).padStart(2, "0") + parseInt(b).toString(16).padStart(2, "0");
          colorPickerEl.value = hexColor;
        }
      }
    }));
    const hideEmbeddedNoteTitlesSetting = new import_obsidian.Setting(containerEl).setName("Hide Embedded Note Titles").setDesc("Hide titles of embedded notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideEmbeddedNoteTitles).onChange(async (value) => {
      this.plugin.settings.hideEmbeddedNoteTitles = value;
      await this.plugin.saveSettings();
      this.plugin.updateEmbeddedTitlesVisibility();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.hideEmbeddedNoteTitles = DEFAULT_SETTINGS.hideEmbeddedNoteTitles;
      await this.plugin.saveSettings();
      const toggleComponent = hideEmbeddedNoteTitlesSetting.components[0];
      if (toggleComponent) {
        toggleComponent.setValue(DEFAULT_SETTINGS.hideEmbeddedNoteTitles);
      }
      this.plugin.updateEmbeddedTitlesVisibility();
    }));
    const hideEmbeddedNoteBannersSetting = new import_obsidian.Setting(containerEl).setName("Hide Embedded Note Banners").setDesc("Hide banners of embedded notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideEmbeddedNoteBanners).onChange(async (value) => {
      this.plugin.settings.hideEmbeddedNoteBanners = value;
      await this.plugin.saveSettings();
      this.plugin.updateEmbeddedBannersVisibility();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.hideEmbeddedNoteBanners = DEFAULT_SETTINGS.hideEmbeddedNoteBanners;
      await this.plugin.saveSettings();
      const toggleComponent = hideEmbeddedNoteBannersSetting.components[0];
      if (toggleComponent) {
        toggleComponent.setValue(DEFAULT_SETTINGS.hideEmbeddedNoteBanners);
      }
      this.plugin.updateEmbeddedBannersVisibility();
    }));
    const SelectImageSettingsGroup = containerEl.createDiv({ cls: "setting-group" });
    const showSelectImageIconSetting = new import_obsidian.Setting(SelectImageSettingsGroup).setName("Show Select Image Icon").setDesc("Show an icon to select banner image in the top-left corner").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSelectImageIcon).onChange(async (value) => {
      this.plugin.settings.showSelectImageIcon = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.showSelectImageIcon = DEFAULT_SETTINGS.showSelectImageIcon;
      await this.plugin.saveSettings();
      const toggleComponent = showSelectImageIconSetting.components[0];
      if (toggleComponent) {
        toggleComponent.setValue(DEFAULT_SETTINGS.showSelectImageIcon);
      }
      this.plugin.updateAllBanners();
    }));
    const defaultSelectImagePathSetting = new import_obsidian.Setting(SelectImageSettingsGroup).setName("Default Select Image Path").setDesc("Set a default folder path to filter images when opening the Select Image modal").addText((text) => {
      text.setPlaceholder("Example: Images/Banners").setValue(this.plugin.settings.defaultSelectImagePath).onChange(async (value) => {
        this.plugin.settings.defaultSelectImagePath = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "200px";
      return text;
    }).addButton((button) => button.setButtonText("Browse").onClick(() => {
      new FolderSuggestModal(this.plugin.app, (chosenPath) => {
        this.plugin.settings.defaultSelectImagePath = chosenPath;
        const textInput = defaultSelectImagePathSetting.components[0];
        if (textInput) {
          textInput.setValue(chosenPath);
        }
        this.plugin.saveSettings();
      }).open();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.defaultSelectImagePath = DEFAULT_SETTINGS.defaultSelectImagePath;
      await this.plugin.saveSettings();
      const textComponent = defaultSelectImagePathSetting.components[0];
      if (textComponent) {
        textComponent.setValue(DEFAULT_SETTINGS.defaultSelectImagePath);
      }
    }));
    const showViewImageIconSetting = new import_obsidian.Setting(containerEl).setName("Show View Image Icon").setDesc("Show an icon to view the banner image in full screen").addToggle((toggle) => toggle.setValue(this.plugin.settings.showViewImageIcon).onChange(async (value) => {
      this.plugin.settings.showViewImageIcon = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.showViewImageIcon = DEFAULT_SETTINGS.showViewImageIcon;
      await this.plugin.saveSettings();
      const toggleComponent = showViewImageIconSetting.components[0];
      if (toggleComponent) {
        toggleComponent.setValue(DEFAULT_SETTINGS.showViewImageIcon);
      }
      this.plugin.updateAllBanners();
    }));
    const hideSettingsGroup = containerEl.createDiv({ cls: "setting-group" });
    const hidePixelBannerFieldsSetting = new import_obsidian.Setting(hideSettingsGroup).setName("Hide Pixel Banner Fields").setDesc("Hide banner-related frontmatter fields in Reading mode").addToggle((toggle) => toggle.setValue(this.plugin.settings.hidePixelBannerFields).onChange(async (value) => {
      this.plugin.settings.hidePixelBannerFields = value;
      if (!value) {
        this.plugin.settings.hidePropertiesSectionIfOnlyBanner = false;
        const dependentToggle = hidePropertiesSection.components[0];
        if (dependentToggle) {
          dependentToggle.setValue(false);
          dependentToggle.setDisabled(true);
        }
        hidePropertiesSection.settingEl.addClass("is-disabled");
        this.app.workspace.iterateAllLeaves((leaf) => {
          if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.contentEl) {
            const propertiesContainer = leaf.view.contentEl.querySelector(".metadata-container");
            if (propertiesContainer) {
              propertiesContainer.classList.remove("pixel-banner-hidden-section");
              const hiddenFields = propertiesContainer.querySelectorAll(".pixel-banner-hidden-field");
              hiddenFields.forEach((field) => {
                field.classList.remove("pixel-banner-hidden-field");
              });
            }
          }
        });
      } else {
        const dependentToggle = hidePropertiesSection.components[0];
        if (dependentToggle) {
          dependentToggle.setDisabled(false);
        }
        hidePropertiesSection.settingEl.removeClass("is-disabled");
      }
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.hidePixelBannerFields = DEFAULT_SETTINGS.hidePixelBannerFields;
      this.plugin.settings.hidePropertiesSectionIfOnlyBanner = DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner;
      await this.plugin.saveSettings();
      const mainToggle = hidePixelBannerFieldsSetting.components[0];
      if (mainToggle) {
        mainToggle.setValue(DEFAULT_SETTINGS.hidePixelBannerFields);
      }
      const dependentToggle = hidePropertiesSection.components[0];
      if (dependentToggle) {
        dependentToggle.setValue(DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner);
        dependentToggle.setDisabled(!DEFAULT_SETTINGS.hidePixelBannerFields);
      }
      hidePropertiesSection.settingEl.toggleClass("is-disabled", !DEFAULT_SETTINGS.hidePixelBannerFields);
      this.plugin.updateAllBanners();
    }));
    const hidePropertiesSection = new import_obsidian.Setting(hideSettingsGroup).setName("Hide Properties Section").setDesc("Hide the entire Properties section in Reading mode if it only contains Pixel Banner fields").addToggle((toggle) => toggle.setValue(this.plugin.settings.hidePropertiesSectionIfOnlyBanner).setDisabled(!this.plugin.settings.hidePixelBannerFields).onChange(async (value) => {
      this.plugin.settings.hidePropertiesSectionIfOnlyBanner = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.hidePropertiesSectionIfOnlyBanner = DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner;
      await this.plugin.saveSettings();
      const toggle = hidePropertiesSection.components[0];
      if (toggle) {
        toggle.setValue(DEFAULT_SETTINGS.hidePropertiesSectionIfOnlyBanner);
      }
      this.plugin.updateAllBanners();
    }));
    hidePropertiesSection.settingEl.addClass("setting-dependent");
    if (!this.plugin.settings.hidePixelBannerFields) {
      hidePropertiesSection.settingEl.addClass("is-disabled");
    }
    const showReleaseNotesSetting = new import_obsidian.Setting(containerEl).setName("Show Release Notes").setDesc("Show release notes after plugin updates").addToggle((toggle) => toggle.setValue(this.plugin.settings.showReleaseNotes).onChange(async (value) => {
      this.plugin.settings.showReleaseNotes = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.showReleaseNotes = DEFAULT_SETTINGS.showReleaseNotes;
      await this.plugin.saveSettings();
      const toggleComponent = showReleaseNotesSetting.components[0];
      if (toggleComponent) {
        toggleComponent.setValue(DEFAULT_SETTINGS.showReleaseNotes);
      }
    }));
  }
  createCustomFieldsSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: 'Customize the frontmatter field names used for the banner and Y-position. You can define multiple names for each field, separated by commas. Field names can only contain letters, numbers, dashes, and underscores. Example: "banner, pixel-banner, header_image" could all be used as the banner field name.' });
    const customFields = [
      {
        setting: "customBannerField",
        name: "Banner Field Names",
        desc: "Set custom field names for the banner in frontmatter (comma-separated)",
        values: '[[image.png]], "images/image.jpg"',
        placeholder: "banner, pixel-banner, header-image"
      },
      {
        setting: "customYPositionField",
        name: "Y-Position Field Names",
        desc: "Set custom field names for the Y-position in frontmatter (comma-separated)",
        values: "5, 70, 100",
        placeholder: "banner-y, y-position, banner-offset"
      },
      {
        setting: "customXPositionField",
        name: "X-Position Field Names",
        desc: "Set custom field names for the X-position in frontmatter (comma-separated)",
        values: "0, 30, 90",
        placeholder: "banner-x, x-position, banner-offset-x"
      },
      {
        setting: "customContentStartField",
        name: "Content Start Position Field Names",
        desc: "Set custom field names for the content start position in frontmatter (comma-separated)",
        values: "75, 150, 450",
        placeholder: "content-start, start-position, content-offset"
      },
      {
        setting: "customImageDisplayField",
        name: "Image Display Field Names",
        desc: "Set custom field names for the image display in frontmatter (comma-separated)",
        values: "cover, contain, auto, 200%, 70%",
        placeholder: "banner-display, image-display, display-mode"
      },
      {
        setting: "customImageRepeatField",
        name: "Image Repeat Field Names",
        desc: "Set custom field names for the image repeat in frontmatter (comma-separated)",
        values: "true, false",
        placeholder: "banner-repeat, image-repeat, repeat-image"
      },
      {
        setting: "customBannerHeightField",
        name: "Banner Height Field Names",
        desc: "Set custom field names for the banner height in frontmatter (comma-separated)",
        values: "100, 300, 700",
        placeholder: "banner-height, image-height, header-height"
      },
      {
        setting: "customFadeField",
        name: "Fade Field Names",
        desc: "Set custom field names for the fade effect in frontmatter (comma-separated)",
        values: "-1000, -100, 100",
        placeholder: "banner-fade, fade-effect, image-fade"
      },
      {
        setting: "customBorderRadiusField",
        name: "Border Radius Field Names",
        desc: "Set custom field names for the border radius in frontmatter (comma-separated)",
        values: "0, 17, 30, 50",
        placeholder: "banner-radius, border-radius, banner-corner-radius"
      },
      {
        setting: "customTitleColorField",
        name: "Inline Title Color Field Names",
        desc: "Set custom field names for the inline title color in frontmatter (comma-separated)",
        values: 'red, papayawhip, "#7f6df2", "#ffa500"',
        placeholder: "banner-title-color, title-color, header-color"
      },
      {
        setting: "customBannerShuffleField",
        name: "Banner Shuffle Field Names",
        desc: "Set custom field names for the banner shuffle in frontmatter (comma-separated)",
        values: '"pixel-banner-images", "images/llamas"',
        placeholder: "banner-shuffle, shuffle-folder, random-image-folder"
      }
    ];
    customFields.forEach((field) => {
      const settingContainer = new import_obsidian.Setting(containerEl).setName(field.name).setDesc(field.desc);
      if (field.values) {
        settingContainer.descEl.createEl("div", {
          text: `example frontmatter values: ${field.values}`,
          cls: "setting-item-description pixel-banner-example-values"
        });
      }
      settingContainer.addText((text) => {
        text.setPlaceholder(field.placeholder).setValue(arrayToString(this.plugin.settings[field.setting])).onChange(async (value) => {
          const newNames = stringToArray(value);
          const validation = validateFieldNames(
            this.plugin.settings,
            customFields.map((f) => f.setting),
            field.setting,
            newNames
          );
          if (validation.isValid) {
            this.plugin.settings[field.setting] = newNames;
            await this.plugin.saveSettings();
          } else {
            new Notice(validation.message);
            text.setValue(arrayToString(this.plugin.settings[field.setting]));
          }
        });
        text.inputEl.style.width = "220px";
      }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[field.setting] = DEFAULT_SETTINGS[field.setting];
        await this.plugin.saveSettings();
        const settingEl = button.extraSettingsEl.parentElement;
        const textInput = settingEl.querySelector('input[type="text"]');
        textInput.value = arrayToString(DEFAULT_SETTINGS[field.setting]);
        const event = new Event("input", { bubbles: true, cancelable: true });
        textInput.dispatchEvent(event);
      }));
    });
  }
  createFolderSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Configure banner settings for specific folders. These settings will override the default settings for all notes in the specified folder." });
    const folderImagesContainer = containerEl.createEl("div", { cls: "folder-images-container" });
    this.plugin.settings.folderImages.forEach((folderImage, index) => {
      new FolderImageSetting(
        folderImagesContainer,
        this.plugin,
        folderImage,
        index,
        () => this.updateFolderSettings()
      );
    });
    const addFolderImageSetting = new import_obsidian.Setting(containerEl).setClass("add-folder-image-setting").addButton((button) => button.setButtonText("Add Folder Image").onClick(async () => {
      const newFolderImage = {
        folder: "",
        image: "",
        imageDisplay: "cover",
        imageRepeat: false,
        yPosition: 50,
        xPosition: 50,
        contentStartPosition: 150,
        bannerHeight: 350,
        fade: -75,
        borderRadius: 17,
        titleColor: "var(--inline-title-color)",
        directChildrenOnly: false,
        enableImageShuffle: false,
        shuffleFolder: ""
      };
      this.plugin.settings.folderImages.push(newFolderImage);
      await this.plugin.saveSettings();
      this.updateFolderSettings();
    }));
  }
  createExampleSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("How to use").setHeading().settingEl.querySelector(".setting-item-name").style.cssText = "color: var(--text-accent-hover); font-size: var(--font-ui-large);";
    const getRandomFieldName = (fieldNames) => {
      const names = Array.isArray(fieldNames) ? fieldNames : [fieldNames];
      return names[Math.floor(Math.random() * names.length)];
    };
    const instructionsEl = containerEl.createEl("div", { cls: "pixel-banner-section" });
    instructionsEl.createEl("p", { text: "Add the following fields to your note's frontmatter to customize the banner:" });
    const codeEl = instructionsEl.createEl("pre");
    codeEl.createEl("code", {
      text: `---
${getRandomFieldName(this.plugin.settings.customBannerField)}: blue turtle
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 30
${getRandomFieldName(this.plugin.settings.customXPositionField)}: 30
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 200
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: true
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 400
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 25
${getRandomFieldName(this.plugin.settings.customTitleColorField)}: #ff0000
---

# Or use a direct URL:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: https://example.com/image.jpg
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 70
${getRandomFieldName(this.plugin.settings.customXPositionField)}: 70
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 180
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: 200%
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 300
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 0
${getRandomFieldName(this.plugin.settings.customTitleColorField)}: #00ff00
---

# Or use a path to an image in the vault:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: Assets/my-image.png
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 0
${getRandomFieldName(this.plugin.settings.customXPositionField)}: 0
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 100
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: auto
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 250
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 50
${getRandomFieldName(this.plugin.settings.customTitleColorField)}: #0000ff
---

# Or use an Obsidian internal link:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: [[example-image.png]]
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 100
${getRandomFieldName(this.plugin.settings.customXPositionField)}: 100
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 50
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: false
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 500
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 17
${getRandomFieldName(this.plugin.settings.customTitleColorField)}: #ff00ff
---`
    });
    instructionsEl.createEl("p", { text: 'Note: The image display options are "auto", "cover", or "contain". The image repeat option is only applicable when the display is set to "contain".' });
    containerEl.createEl("img", {
      attr: {
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/main/example.jpg",
        alt: "Example of a Pixel banner",
        style: "max-width: 100%; height: auto; margin-top: 10px; border-radius: 5px;"
      }
    });
  }
  validateFieldName(value, otherFieldName) {
    if (value === otherFieldName) {
      new Notice("Field names must be unique!");
      return false;
    }
    return true;
  }
};
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function random20characters() {
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < 20; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}
async function testPexelsApi(apiKey) {
  try {
    const response = await fetch(`https://api.pexels.com/v1/search?query=${random20characters()}&per_page=3`, {
      headers: {
        "Authorization": apiKey
      }
    });
    if (!response.ok) {
      throw new Error("\u274C Invalid Pexels API key");
    }
    const data = await response.json();
    return data.photos;
  } catch (error) {
    return false;
  }
}
async function testPixabayApi(apiKey) {
  try {
    const response = await fetch(`https://pixabay.com/api/?key=${apiKey}&q=test&per_page=3`);
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }
    return true;
  } catch (error) {
    return false;
  }
}
async function testFlickrApi(apiKey) {
  try {
    const response = await fetch(`https://www.flickr.com/services/rest/?method=flickr.test.echo&api_key=${apiKey}&format=json&nojsoncallback=1`);
    const data = await response.json();
    return data.stat === "ok";
  } catch (error) {
    return false;
  }
}
async function testUnsplashApi(apiKey) {
  try {
    const response = await fetch("https://api.unsplash.com/photos/random", {
      headers: {
        "Authorization": `Client-ID ${apiKey}`
      }
    });
    return response.ok;
  } catch (error) {
    return false;
  }
}

// src/modals.js
var import_obsidian2 = require("obsidian");
var ReleaseNotesModal = class extends import_obsidian2.Modal {
  constructor(app2, version, releaseNotes2) {
    super(app2);
    this.version = version;
    this.releaseNotes = releaseNotes2;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Welcome to \u{1F6A9} Pixel Banner v${this.version}` });
    contentEl.createEl("p", {
      text: "After each update you'll be prompted with the release notes. You can disable this in the plugin settings General tab.",
      cls: "release-notes-instructions"
    });
    const promotionalLinks = contentEl.createEl("div");
    promotionalLinks.style.display = "flex";
    promotionalLinks.style.flexDirection = "row";
    promotionalLinks.style.justifyContent = "space-around";
    const equilllabsLink = promotionalLinks.createEl("a", {
      href: "https://www.equilllabs.com",
      target: "equilllabs"
    });
    equilllabsLink.createEl("img", {
      attr: {
        height: "36",
        style: "border:0px;height:36px;",
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/refs/heads/main/img/equilllabs.png?raw=true",
        border: "0",
        alt: "eQuill Labs"
      }
    });
    const discordLink = promotionalLinks.createEl("a", {
      href: "https://discord.gg/sp8AQQhMJ7",
      target: "discord"
    });
    discordLink.createEl("img", {
      attr: {
        height: "36",
        style: "border:0px;height:36px;",
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/refs/heads/main/img/discord.png?raw=true",
        border: "0",
        alt: "Discord"
      }
    });
    const kofiLink = promotionalLinks.createEl("a", {
      href: "https://ko-fi.com/Z8Z212UMBI",
      target: "kofi"
    });
    kofiLink.createEl("img", {
      attr: {
        height: "36",
        style: "border:0px;height:36px;",
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/refs/heads/main/img/support.png?raw=true",
        border: "0",
        alt: "Buy Me a Coffee at ko-fi.com"
      }
    });
    const notesContainer = contentEl.createDiv("release-notes-container");
    notesContainer.innerHTML = this.releaseNotes;
    contentEl.createEl("div", { cls: "release-notes-spacer" }).style.height = "20px";
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ImageViewModal = class extends import_obsidian2.Modal {
  constructor(app2, imageUrl) {
    super(app2);
    this.imageUrl = imageUrl;
  }
  onOpen() {
    this.modalEl.addClass("pixel-banner-image-modal");
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("pixel-banner-image-view-modal");
    const imageContainer = contentEl.createDiv("image-container");
    const img = imageContainer.createEl("img", {
      attr: {
        src: this.imageUrl,
        style: "max-width: 100%; max-height: 90vh; object-fit: contain;"
      }
    });
    const closeButton = contentEl.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeButton.style.marginTop = "10px";
    closeButton.addEventListener("click", () => this.close());
    this.scope.register([], "Escape", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ImageSelectionModal = class extends import_obsidian2.Modal {
  constructor(app2, plugin, onChoose, defaultPath = "") {
    super(app2);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this.defaultPath = defaultPath;
    this.searchQuery = defaultPath.toLowerCase();
    this.currentPage = 1;
    this.imagesPerPage = 20;
    this.sortOrder = "name-asc";
    this.imageFiles = this.app.vault.getFiles().filter((file) => file.extension.toLowerCase().match(/^(jpg|jpeg|png|gif|bmp|svg|webp)$/));
  }
  debounce(func, wait) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  onOpen() {
    this.modalEl.addClass("pixel-banner-image-select-modal");
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Banner Image" });
    contentEl.createEl("div", {
      text: "Select an image from your vault or upload a new one.",
      cls: "pixel-banner-image-select-description"
    });
    const searchContainer = contentEl.createDiv({ cls: "pixel-banner-search-container" });
    searchContainer.style.display = "flex";
    searchContainer.style.gap = "8px";
    searchContainer.style.alignItems = "center";
    searchContainer.style.marginBottom = "1em";
    const searchRow = searchContainer.createDiv({ cls: "search-row" });
    const searchInput = searchRow.createEl("input", {
      type: "text",
      placeholder: "Search images...",
      value: this.defaultPath
    });
    searchInput.style.flex = "1";
    const clearButton = searchRow.createEl("button", {
      text: "Clear"
    });
    const controlsRow = searchContainer.createDiv({ cls: "controls-row" });
    const uploadButton = controlsRow.createEl("button", {
      text: "\u{1F4E4} Upload External Image"
    });
    const toggleContainer = controlsRow.createDiv({
      cls: "pixel-banner-path-toggle",
      attr: {
        style: "display: flex; align-items: center; gap: 8px;"
      }
    });
    const toggleLabel = toggleContainer.createSpan({
      text: "Use short path",
      attr: {
        style: "font-size: 12px; color: var(--text-muted);"
      }
    });
    const toggle = new import_obsidian2.Setting(toggleContainer).addToggle((cb) => {
      cb.setValue(this.plugin.settings.useShortPath).onChange(async (value) => {
        this.plugin.settings.useShortPath = value;
        await this.plugin.saveSettings();
      });
    });
    toggle.settingEl.style.border = "none";
    toggle.settingEl.style.padding = "0";
    toggle.settingEl.style.margin = "0";
    toggle.infoEl.remove();
    const fileInput = searchContainer.createEl("input", {
      type: "file",
      attr: {
        accept: "image/*",
        style: "display: none;"
      }
    });
    uploadButton.addEventListener("click", () => {
      fileInput.click();
    });
    fileInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = async () => {
          const arrayBuffer = reader.result;
          const defaultFolder = this.plugin.settings.pinnedImageFolder || "";
          const folderPath = await new Promise((resolve) => {
            new FolderSelectionModal(this.app, defaultFolder, (result) => {
              resolve(result);
            }).open();
          });
          if (!folderPath) {
            new import_obsidian2.Notice("No folder selected");
            return;
          }
          if (!await this.app.vault.adapter.exists(folderPath)) {
            await this.app.vault.createFolder(folderPath);
          }
          const suggestedName = file.name;
          const fileName = await new Promise((resolve) => {
            new SaveImageModal(this.app, suggestedName, (result) => {
              resolve(result);
            }).open();
          });
          if (!fileName) {
            new import_obsidian2.Notice("No file name provided");
            return;
          }
          try {
            const fullPath = `${folderPath}/${fileName}`.replace(/\/+/g, "/");
            const newFile = await this.app.vault.createBinary(fullPath, arrayBuffer);
            this.onChoose(newFile);
            this.close();
          } catch (error) {
            new import_obsidian2.Notice("Failed to save image: " + error.message);
          }
        };
        reader.readAsArrayBuffer(file);
      }
    });
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      this.searchQuery = "";
      this.updateImageGrid();
    });
    searchInput.addEventListener("input", this.debounce(() => {
      this.searchQuery = searchInput.value.toLowerCase();
      this.updateImageGrid();
    }, 500));
    this.gridContainer = contentEl.createDiv({ cls: "pixel-banner-image-grid" });
    this.paginationContainer = contentEl.createDiv({ cls: "pixel-banner-pagination" });
    this.paginationContainer.style.display = "flex";
    this.paginationContainer.style.justifyContent = "center";
    this.paginationContainer.style.alignItems = "center";
    this.paginationContainer.style.marginTop = "1em";
    this.paginationContainer.style.gap = "10px";
    this.updateImageGrid();
  }
  updateImageGrid() {
    this.gridContainer.empty();
    this.paginationContainer.empty();
    let filteredFiles = this.imageFiles.filter((file) => {
      const filePath = file.path.toLowerCase();
      const fileName = file.name.toLowerCase();
      return filePath.includes(this.searchQuery) || fileName.includes(this.searchQuery);
    });
    filteredFiles = this.sortFiles(filteredFiles);
    const totalImages = filteredFiles.length;
    const totalPages = Math.ceil(totalImages / this.imagesPerPage);
    const startIndex = (this.currentPage - 1) * this.imagesPerPage;
    const endIndex = Math.min(startIndex + this.imagesPerPage, totalImages);
    const currentFiles = filteredFiles.slice(startIndex, endIndex);
    currentFiles.forEach((file) => {
      const imageContainer = this.gridContainer.createDiv({ cls: "pixel-banner-image-container" });
      const thumbnailContainer = imageContainer.createDiv();
      if (file.extension.toLowerCase() === "svg") {
        this.app.vault.read(file).then((content) => {
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(content, "image/svg+xml");
          const svgElement = svgDoc.documentElement;
          svgElement.classList.add("pixel-banner-image-thumbnail");
          svgElement.style.width = "100%";
          svgElement.style.height = "100%";
          thumbnailContainer.empty();
          thumbnailContainer.appendChild(svgElement);
        }).catch(() => {
          thumbnailContainer.createEl("div", {
            cls: "pixel-banner-image-error",
            text: "Error loading SVG"
          });
        });
      } else {
        this.app.vault.readBinary(file).then((arrayBuffer) => {
          const blob = new Blob([arrayBuffer]);
          const url = URL.createObjectURL(blob);
          const img = thumbnailContainer.createEl("img", {
            cls: "pixel-banner-image-thumbnail",
            attr: { src: url }
          });
          const cleanup = () => URL.revokeObjectURL(url);
          img.addEventListener("load", cleanup);
          img.addEventListener("error", cleanup);
        }).catch(() => {
          thumbnailContainer.createEl("div", {
            cls: "pixel-banner-image-error",
            text: "Error loading image"
          });
        });
      }
      const infoContainer = imageContainer.createDiv("pixel-banner-image-info");
      infoContainer.createEl("div", {
        cls: "pixel-banner-image-path",
        text: file.path
      });
      const statsContainer = infoContainer.createDiv("pixel-banner-image-stats");
      statsContainer.style.fontSize = "0.8em";
      statsContainer.style.color = "var(--text-muted)";
      const fileSize = this.formatFileSize(file.stat.size);
      const modifiedDate = this.formatDate(file.stat.mtime);
      statsContainer.createEl("span", {
        text: `${fileSize} \u2022 ${modifiedDate}`
      });
      imageContainer.addEventListener("click", () => {
        this.onChoose(file);
        this.close();
      });
    });
    if (this.imageFiles.length > 0) {
      const controlsContainer = this.paginationContainer.createDiv({ cls: "pixel-banner-controls" });
      controlsContainer.style.display = "flex";
      controlsContainer.style.justifyContent = "center";
      controlsContainer.style.gap = "50px";
      controlsContainer.style.alignItems = "center";
      controlsContainer.style.width = "100%";
      const sortContainer = controlsContainer.createDiv({ cls: "pixel-banner-sort-container" });
      const sortSelect = sortContainer.createEl("select", { cls: "dropdown" });
      const sortOptions = [
        { value: "name-asc", label: "Name (A-Z)" },
        { value: "name-desc", label: "Name (Z-A)" },
        { value: "date-desc", label: "Date Modified (Newest)" },
        { value: "date-asc", label: "Date Modified (Oldest)" },
        { value: "size-desc", label: "Size (Largest)" },
        { value: "size-asc", label: "Size (Smallest)" }
      ];
      sortOptions.forEach((option) => {
        const optionEl = sortSelect.createEl("option", {
          value: option.value,
          text: option.label
        });
        if (option.value === this.sortOrder) {
          optionEl.selected = true;
        }
      });
      sortSelect.addEventListener("change", () => {
        this.sortOrder = sortSelect.value;
        this.currentPage = 1;
        this.updateImageGrid();
      });
      const paginationDiv = controlsContainer.createDiv({ cls: "pixel-banner-pagination-buttons" });
      paginationDiv.style.display = "flex";
      paginationDiv.style.gap = "10px";
      paginationDiv.style.alignItems = "center";
      const firstButton = paginationDiv.createEl("button", {
        text: "\xAB",
        cls: "pixel-banner-pagination-button",
        attr: {
          "aria-label": "First page",
          title: "First page"
        }
      });
      firstButton.disabled = this.currentPage === 1;
      firstButton.onclick = () => {
        if (this.currentPage !== 1) {
          this.currentPage = 1;
          this.updateImageGrid();
        }
      };
      const prevButton = paginationDiv.createEl("button", {
        text: "\u2039",
        cls: "pixel-banner-pagination-button",
        attr: {
          "aria-label": "Previous page",
          title: "Previous page"
        }
      });
      prevButton.disabled = this.currentPage === 1;
      prevButton.onclick = () => {
        if (this.currentPage > 1) {
          this.currentPage--;
          this.updateImageGrid();
        }
      };
      paginationDiv.createEl("span", {
        text: `${this.currentPage} / ${totalPages}`,
        cls: "pixel-banner-pagination-info"
      });
      const nextButton = paginationDiv.createEl("button", {
        text: "\u203A",
        cls: "pixel-banner-pagination-button",
        attr: {
          "aria-label": "Next page",
          title: "Next page"
        }
      });
      nextButton.disabled = this.currentPage === totalPages;
      nextButton.onclick = () => {
        if (this.currentPage < totalPages) {
          this.currentPage++;
          this.updateImageGrid();
        }
      };
      const lastButton = paginationDiv.createEl("button", {
        text: "\xBB",
        cls: "pixel-banner-pagination-button",
        attr: {
          "aria-label": "Last page",
          title: "Last page"
        }
      });
      lastButton.disabled = this.currentPage === totalPages;
      lastButton.onclick = () => {
        if (this.currentPage !== totalPages) {
          this.currentPage = totalPages;
          this.updateImageGrid();
        }
      };
      const pageInfo = paginationDiv.querySelector(".pixel-banner-pagination-info");
      if (pageInfo) {
        pageInfo.textContent = filteredFiles.length > 0 ? `${this.currentPage} / ${totalPages}` : "No results";
      }
      const buttons = paginationDiv.querySelectorAll("button");
      buttons.forEach((button) => {
        button.disabled = filteredFiles.length === 0 || this.currentPage === 1 && ["\xAB", "\u2039"].includes(button.textContent) || this.currentPage === totalPages && ["\u203A", "\xBB"].includes(button.textContent);
      });
    }
  }
  sortFiles(files) {
    return files.sort((a, b) => {
      switch (this.sortOrder) {
        case "name-asc":
          return a.name.localeCompare(b.name);
        case "name-desc":
          return b.name.localeCompare(a.name);
        case "date-desc":
          return b.stat.mtime - a.stat.mtime;
        case "date-asc":
          return a.stat.mtime - b.stat.mtime;
        case "size-desc":
          return b.stat.size - a.stat.size;
        case "size-asc":
          return a.stat.size - b.stat.size;
        default:
          return 0;
      }
    });
  }
  formatFileSize(bytes) {
    if (bytes < 1024) return bytes + " B";
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
    return (bytes / (1024 * 1024)).toFixed(1) + " MB";
  }
  formatDate(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleDateString();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FolderSelectionModal = class extends import_obsidian2.FuzzySuggestModal {
  constructor(app2, defaultFolder, onChoose) {
    super(app2);
    this.defaultFolder = defaultFolder;
    this.onChoose = onChoose;
    this.setPlaceholder("Select or type folder path to save Banner Image");
    this.titleEl.setText("Choose Folder to save Banner Image");
  }
  getItems() {
    return [this.defaultFolder, ...this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path)];
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
  onOpen() {
    super.onOpen();
    const inputEl = this.inputEl;
    inputEl.value = this.defaultFolder;
    inputEl.select();
    this.updateSuggestions();
  }
};
var SaveImageModal = class extends import_obsidian2.Modal {
  constructor(app2, suggestedName, onSubmit) {
    super(app2);
    this.suggestedName = suggestedName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save Image" });
    contentEl.createEl("p", { text: "Enter a name for the image file." });
    const fileNameSetting = new import_obsidian2.Setting(contentEl).setName("File name").addText((text) => text.setValue(this.suggestedName).onChange((value) => {
      this.suggestedName = value;
    }));
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.marginTop = "1em";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    cancelButton.addEventListener("click", () => this.close());
    saveButton.addEventListener("click", () => {
      if (this.suggestedName) {
        this.onSubmit(this.suggestedName);
        this.close();
      } else {
        new import_obsidian2.Notice("Please enter a file name");
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// virtual-module:virtual:release-notes
var releaseNotes = '<h2>\u{1F389} What&#39;s New</h2>\n<h3>v2.19.2</h3>\n<h4>\u{1F41B} Fixed</h4>\n<ul>\n<li>Fixed issue where content start position was not being applied from General settings</li>\n</ul>\n<h3>v2.19.1</h3>\n<h4>\u2728 Added</h4>\n<ul>\n<li>Show example frontmatter values for each field in &quot;Custom Field Names&quot; settings tab</li>\n</ul>\n<h4>\u{1F4E6} Updated</h4>\n<ul>\n<li>Updated CSS to address padding issue with <code>Bread Crumbs</code> and <code>Typwriter Mode</code> plugins</li>\n</ul>\n<h3>v2.19.0</h3>\n<h4>\u2728 Added</h4>\n<ul>\n<li>Horizontal image positioning with new X-Position slider</li>\n<li>X-Position support in General, Folder Image, and Frontmatter settings</li>\n</ul>\n<p><a href="https://raw.githubusercontent.com/jparkerweb/ref/refs/heads/main/equill-labs/pixel-banner/pixel-banner-v2.19.0.jpg"><img src="https://raw.githubusercontent.com/jparkerweb/ref/refs/heads/main/equill-labs/pixel-banner/pixel-banner-v2.19.0.jpg" alt="screenshot"></a></p>\n';

// src/main.js
function getFrontmatterValue(frontmatter, fieldNames) {
  if (!frontmatter || !fieldNames) return null;
  const fields = Array.isArray(fieldNames) ? fieldNames : [fieldNames];
  for (const field of fields) {
    if (frontmatter.hasOwnProperty(field)) {
      const value = frontmatter[field];
      if (typeof value === "string" && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
      }
      return value;
    }
  }
  return null;
}
module.exports = class PixelBannerPlugin extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "debounceTimer", null);
    __publicField(this, "loadedImages", /* @__PURE__ */ new Map());
    __publicField(this, "lastKeywords", /* @__PURE__ */ new Map());
    __publicField(this, "imageCache", /* @__PURE__ */ new Map());
    __publicField(this, "rateLimiter", {
      lastRequestTime: 0,
      minInterval: 1e3
      // 1 second between requests
    });
    __publicField(this, "lastYPositions", /* @__PURE__ */ new Map());
    __publicField(this, "lastFrontmatter", /* @__PURE__ */ new Map());
    __publicField(this, "debouncedEnsureBanner", debounce(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view instanceof import_obsidian3.MarkdownView) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100));
  }
  async onload() {
    await this.loadSettings();
    this.updateEmbeddedTitlesVisibility();
    await this.checkVersion();
    this.addSettingTab(new PixelBannerSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this))
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file) => {
        var _a;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if (!frontmatter) return;
        const previousFrontmatter = this.lastFrontmatter.get(file.path);
        if (JSON.stringify(frontmatter) === JSON.stringify(previousFrontmatter)) {
          return;
        }
        const relevantFields = [
          ...this.settings.customBannerField,
          ...this.settings.customYPositionField,
          ...this.settings.customXPositionField,
          ...this.settings.customContentStartField,
          ...this.settings.customImageDisplayField,
          ...this.settings.customImageRepeatField,
          ...this.settings.customBannerHeightField,
          ...this.settings.customFadeField,
          ...this.settings.customBorderRadiusField
        ];
        const hasRelevantFieldChange = relevantFields.some(
          (field) => frontmatter[field] !== (previousFrontmatter == null ? void 0 : previousFrontmatter[field])
        );
        if (!hasRelevantFieldChange) return;
        this.lastFrontmatter.set(file.path, frontmatter);
        const leaves = this.app.workspace.getLeavesOfType("markdown");
        for (const leaf of leaves) {
          if (leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file === file && !leaf.containerEl.style.display && leaf.containerEl.matches(".workspace-leaf")) {
            this.loadedImages.delete(file.path);
            this.lastKeywords.delete(file.path);
            await this.updateBanner(leaf.view, true);
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", this.handleLayoutChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("mode-change", this.handleModeChange.bind(this))
    );
    this.registerMarkdownPostProcessor(this.postProcessor.bind(this));
    this.setupMutationObserver();
    this.addCommand({
      id: "pin-banner-image",
      name: "\u{1F4CC} Pin current banner image",
      checkCallback: (checking) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView || !activeView.file) return false;
        const imageUrl = this.loadedImages.get(activeView.file.path);
        const frontmatter = (_a = this.app.metadataCache.getFileCache(activeView.file)) == null ? void 0 : _a.frontmatter;
        let bannerImage, usedField;
        for (const field of this.settings.customBannerField) {
          if (frontmatter == null ? void 0 : frontmatter[field]) {
            bannerImage = frontmatter[field];
            usedField = field;
            break;
          }
        }
        const inputType = this.getInputType(bannerImage);
        const canPin = imageUrl && (inputType === "keyword" || inputType === "url") && this.settings.showPinIcon;
        if (checking) return canPin;
        if (canPin) {
          setTimeout(() => handlePinIconClick(imageUrl, this, usedField), 0);
        }
        return true;
      }
    });
    this.addCommand({
      id: "refresh-banner-image",
      name: "\u{1F504} Refresh current banner image",
      checkCallback: (checking) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView || !activeView.file) return false;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(activeView.file)) == null ? void 0 : _a.frontmatter;
        let bannerImage;
        for (const field of this.settings.customBannerField) {
          if (frontmatter == null ? void 0 : frontmatter[field]) {
            bannerImage = frontmatter[field];
            break;
          }
        }
        const inputType = this.getInputType(bannerImage);
        const canRefresh = inputType === "keyword" && this.settings.showPinIcon && this.settings.showRefreshIcon;
        if (checking) return canRefresh;
        if (canRefresh) {
          this.loadedImages.delete(activeView.file.path);
          this.lastKeywords.delete(activeView.file.path);
          this.updateBanner(activeView, true).then(() => {
            new import_obsidian3.Notice("\u{1F504} Refreshed banner image");
          }).catch((error) => {
            console.error("Error refreshing image:", error);
            new import_obsidian3.Notice("\u{1F62D} Failed to refresh image");
          });
        }
        return true;
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-change", async (editor) => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView || !activeView.file) return;
        const currentFrontmatter = (_a = this.app.metadataCache.getFileCache(activeView.file)) == null ? void 0 : _a.frontmatter;
        if (!currentFrontmatter || !currentFrontmatter.hasOwnProperty("pixel-banner") && !currentFrontmatter.hasOwnProperty("pixel-banner-query")) {
          return;
        }
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        if (!line.includes("pixel-banner") && !line.includes("pixel-banner-query")) {
          return;
        }
        await this.updateBanner(activeView, true);
      })
    );
    this.addCommand({
      id: "set-banner-image",
      name: "\u{1F3F7}\uFE0F Select Image",
      callback: () => this.handleSelectImage()
    });
    if (this.settings.bannerGap === void 0) {
      this.settings.bannerGap = DEFAULT_SETTINGS.bannerGap;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.migrateCustomFields();
    if (!Array.isArray(this.settings.folderImages)) {
      this.settings.folderImages = [];
    }
    if (this.settings.folderImages) {
      this.settings.folderImages.forEach((folderImage) => {
        folderImage.imageDisplay = folderImage.imageDisplay || "cover";
        folderImage.imageRepeat = folderImage.imageRepeat || false;
        folderImage.directChildrenOnly = folderImage.directChildrenOnly || false;
      });
    }
  }
  migrateCustomFields() {
    const fieldsToMigrate = [
      "customBannerField",
      "customYPositionField",
      "customXPositionField",
      "customContentStartField",
      "customImageDisplayField",
      "customImageRepeatField",
      "customBannerHeightField",
      "customFadeField",
      "customBorderRadiusField"
    ];
    fieldsToMigrate.forEach((field) => {
      if (typeof this.settings[field] === "string") {
        console.log(`converting ${field} to array`);
        this.settings[field] = [this.settings[field]];
      } else if (!Array.isArray(this.settings[field])) {
        console.log(`setting default value for ${field}`);
        this.settings[field] = DEFAULT_SETTINGS[field];
      }
    });
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.loadedImages.clear();
    this.lastKeywords.clear();
    this.imageCache.clear();
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian3.MarkdownView) {
        this.updateBanner(leaf.view, true);
        if (this.settings.hidePixelBannerFields) {
          this.updateFieldVisibility(leaf.view);
        }
      }
    });
  }
  async handleActiveLeafChange(leaf) {
    const previousLeaf = this.app.workspace.activeLeaf;
    if (previousLeaf && previousLeaf.view instanceof import_obsidian3.MarkdownView) {
      const previousContentEl = previousLeaf.view.contentEl;
      previousContentEl.classList.remove("pixel-banner");
      ["cm-sizer", "markdown-preview-sizer"].forEach((selector) => {
        const container = previousContentEl.querySelector(`.${selector}`);
        if (container) {
          const previousBanner = container.querySelector(".pixel-banner-image");
          if (previousBanner) {
            previousBanner.style.backgroundImage = "";
            previousBanner.style.display = "none";
            if (previousLeaf.view.file) {
              const existingUrl = this.loadedImages.get(previousLeaf.view.file.path);
              if (existingUrl == null ? void 0 : existingUrl.startsWith("blob:")) {
                URL.revokeObjectURL(existingUrl);
              }
              this.loadedImages.delete(previousLeaf.view.file.path);
            }
          }
        }
      });
    }
    if (leaf && leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, false);
    }
  }
  handleLayoutChange() {
    setTimeout(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && (activeLeaf.view instanceof import_obsidian3.MarkdownView || activeLeaf.view.getViewType() === "markdown")) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100);
  }
  async handleModeChange(leaf) {
    if (leaf && leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, true);
      if (this.settings.hidePixelBannerFields) {
        this.updateFieldVisibility(leaf.view);
      }
    }
  }
  async updateBanner(view, isContentChange) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (!view || !view.file) {
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(view.file)) == null ? void 0 : _a.frontmatter;
    const contentEl = view.contentEl;
    const isEmbedded = contentEl.classList.contains("internal-embed") && contentEl.classList.contains("markdown-embed");
    const existingBanner = contentEl.querySelector(".pixel-banner-image");
    const folderSpecific = this.getFolderSpecificImage(view.file.path);
    let bannerImage = null;
    const shufflePath = getFrontmatterValue(frontmatter, this.settings.customBannerShuffleField);
    if (shufflePath) {
      const randomImagePath = await this.getRandomImageFromFolder(shufflePath);
      if (randomImagePath) {
        bannerImage = randomImagePath;
      }
    }
    if (!bannerImage) {
      bannerImage = getFrontmatterValue(frontmatter, this.settings.customBannerField) || (folderSpecific == null ? void 0 : folderSpecific.image);
    }
    if (!isEmbedded && !bannerImage) {
      contentEl.classList.remove("pixel-banner");
      if (existingBanner) {
        existingBanner.style.backgroundImage = "";
        existingBanner.style.display = "none";
      }
    }
    if (isContentChange) {
      this.loadedImages.delete(view.file.path);
      this.lastKeywords.delete(view.file.path);
    }
    let yPosition = (_b = folderSpecific == null ? void 0 : folderSpecific.yPosition) != null ? _b : this.settings.yPosition;
    let xPosition = (_c = folderSpecific == null ? void 0 : folderSpecific.xPosition) != null ? _c : this.settings.xPosition;
    let contentStartPosition = (_d = folderSpecific == null ? void 0 : folderSpecific.contentStartPosition) != null ? _d : this.settings.contentStartPosition;
    if (bannerImage) {
      if (Array.isArray(bannerImage)) {
        bannerImage = bannerImage.flat()[0];
        bannerImage = `[[${bannerImage}]]`;
      }
      if (typeof bannerImage === "string" && !bannerImage.startsWith("[[")) {
        const bannerValues = bannerImage.includes(",") ? bannerImage.split(",").map((v) => v.trim()).filter((v) => v.length > 0).filter(Boolean) : [bannerImage];
        if (bannerValues.length > 0) {
          bannerImage = bannerValues[Math.floor(Math.random() * bannerValues.length)];
        } else {
          bannerImage = null;
        }
      }
      if (bannerImage && !bannerImage.startsWith("[[") && !bannerImage.startsWith("http")) {
        const file = this.app.vault.getAbstractFileByPath(bannerImage);
        if (file && "extension" in file) {
          if (file.extension.match(/^(jpg|jpeg|png|gif|bmp|svg)$/i)) {
            bannerImage = `[[${bannerImage}]]`;
          }
        }
      }
    }
    let imageDisplay = getFrontmatterValue(frontmatter, this.settings.customImageDisplayField) || (folderSpecific == null ? void 0 : folderSpecific.imageDisplay) || this.settings.imageDisplay;
    let imageRepeat = (_f = (_e = getFrontmatterValue(frontmatter, this.settings.customImageRepeatField)) != null ? _e : folderSpecific == null ? void 0 : folderSpecific.imageRepeat) != null ? _f : this.settings.imageRepeat;
    let bannerHeight = (_h = (_g = getFrontmatterValue(frontmatter, this.settings.customBannerHeightField)) != null ? _g : folderSpecific == null ? void 0 : folderSpecific.bannerHeight) != null ? _h : this.settings.bannerHeight;
    let fade = (_j = (_i = getFrontmatterValue(frontmatter, this.settings.customFadeField)) != null ? _i : folderSpecific == null ? void 0 : folderSpecific.fade) != null ? _j : this.settings.fade;
    let borderRadius = (_l = (_k = getFrontmatterValue(frontmatter, this.settings.customBorderRadiusField)) != null ? _k : folderSpecific == null ? void 0 : folderSpecific.borderRadius) != null ? _l : this.settings.borderRadius;
    if (bannerImage) {
      await this.addPixelBanner(contentEl, {
        frontmatter,
        file: view.file,
        isContentChange,
        yPosition,
        xPosition,
        contentStartPosition,
        bannerImage,
        imageDisplay,
        imageRepeat,
        bannerHeight,
        fade,
        borderRadius,
        isReadingView: view.getMode && view.getMode() === "preview"
      });
      this.lastYPositions.set(view.file.path, yPosition);
    } else if (existingBanner) {
      existingBanner.style.display = "none";
    }
    if (!isEmbedded) {
      const embeddedNotes = contentEl.querySelectorAll(".internal-embed.markdown-embed");
      for (const embed of embeddedNotes) {
        const embedFile = this.app.metadataCache.getFirstLinkpathDest(embed.getAttribute("src"), "");
        if (embedFile) {
          const embedView = {
            file: embedFile,
            contentEl: embed,
            getMode: () => "preview"
          };
          await this.updateBanner(embedView, false);
        }
      }
    }
    if (!bannerImage) {
      const viewContent = view.contentEl;
      const isReadingView = view.getMode && view.getMode() === "preview";
      const container = isReadingView ? viewContent.querySelector(".markdown-preview-sizer:not(.internal-embed .markdown-preview-sizer)") : viewContent.querySelector(".cm-sizer");
      if (this.settings.showSelectImageIcon && container) {
        const existingSelectIcon = container.querySelector(".select-image-icon");
        if (!existingSelectIcon) {
          const selectImageIcon = createDiv({ cls: "select-image-icon" });
          selectImageIcon.style.position = "absolute";
          selectImageIcon.style.top = "10px";
          selectImageIcon.style.left = `${this.settings.bannerGap + 5}px`;
          selectImageIcon.style.fontSize = "1.5em";
          selectImageIcon.style.cursor = "pointer";
          selectImageIcon.innerHTML = "\u{1F3F7}\uFE0F";
          selectImageIcon._isPersistentSelectImage = true;
          selectImageIcon.onclick = () => this.handleSelectImage();
          container.insertBefore(selectImageIcon, container.firstChild);
        }
      } else if (!this.settings.showSelectImageIcon && container) {
        const existingSelectIcon = container.querySelector(".select-image-icon");
        if (existingSelectIcon) {
          existingSelectIcon.remove();
        }
      }
      if (container) {
        const existingViewImageIcon = container.querySelector(".view-image-icon");
        if (existingViewImageIcon) {
          existingViewImageIcon.remove();
        }
      }
    }
    if (this.settings.hidePixelBannerFields && view.getMode() === "preview") {
      this.updateFieldVisibility(view);
    }
  }
  setupMutationObserver() {
    this.observer = new MutationObserver((mutations) => {
      for (let mutation of mutations) {
        if (mutation.type === "childList") {
          const removedNodes = Array.from(mutation.removedNodes);
          const addedNodes = Array.from(mutation.addedNodes);
          const bannerRemoved = removedNodes.some(
            (node) => node.classList && node.classList.contains("pixel-banner-image")
          );
          const contentChanged = addedNodes.some(
            (node) => node.nodeType === Node.ELEMENT_NODE && (node.classList.contains("markdown-preview-section") || node.classList.contains("cm-content"))
          );
          if (bannerRemoved || contentChanged) {
            const activeLeaf = this.app.workspace.activeLeaf;
            if (activeLeaf && activeLeaf.view instanceof import_obsidian3.MarkdownView) {
              const contentEl = activeLeaf.view.contentEl;
              const hasBanner = contentEl.querySelector('.pixel-banner-image[style*="display: block"]');
              if (!hasBanner) {
                contentEl.classList.remove("pixel-banner");
              }
            }
            this.debouncedEnsureBanner();
          }
        }
      }
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  getFolderSpecificImage(filePath) {
    const folderPath = this.getFolderPath(filePath);
    const sortedFolderImages = [...this.settings.folderImages].sort(
      (a, b) => {
        var _a, _b;
        return (((_a = b.folder) == null ? void 0 : _a.length) || 0) - (((_b = a.folder) == null ? void 0 : _b.length) || 0);
      }
    );
    for (const folderImage of sortedFolderImages) {
      if (!folderImage.folder) continue;
      if (folderImage.folder === "/") {
        if (folderImage.directChildrenOnly) {
          if (!filePath.includes("/")) {
            return this.createFolderImageSettings(folderImage);
          }
        } else {
          return this.createFolderImageSettings(folderImage);
        }
        continue;
      }
      const normalizedFolderPath = folderImage.folder.startsWith("/") ? folderImage.folder : "/" + folderImage.folder;
      const normalizedFileFolderPath = "/" + folderPath;
      if (folderImage.directChildrenOnly) {
        if (normalizedFileFolderPath === normalizedFolderPath) {
          return this.createFolderImageSettings(folderImage);
        }
      } else {
        if (normalizedFileFolderPath.startsWith(normalizedFolderPath)) {
          return this.createFolderImageSettings(folderImage);
        }
      }
    }
    return null;
  }
  // Helper method to create folder image settings object
  createFolderImageSettings(folderImage) {
    const settings = { ...folderImage };
    if (folderImage.enableImageShuffle && folderImage.shuffleFolder) {
      const randomImagePath = this.getRandomImageFromFolder(folderImage.shuffleFolder);
      if (randomImagePath) {
        settings.image = randomImagePath;
      }
    }
    return settings;
  }
  getFolderPath(filePath) {
    if (!filePath.includes("/")) {
      return "/";
    }
    const lastSlashIndex = filePath.lastIndexOf("/");
    return lastSlashIndex !== -1 ? filePath.substring(0, lastSlashIndex) : "";
  }
  async getImageUrl(type, input) {
    if (type === "url" || type === "path") {
      return input;
    }
    if (type === "obsidianLink") {
      const file = this.getPathFromObsidianLink(input);
      if (file) {
        return this.getVaultImageUrl(file.path);
      }
      return null;
    }
    if (type === "vaultPath") {
      return this.getVaultImageUrl(input);
    }
    if (type === "keyword") {
      const keywords = input.includes(",") ? input.split(",").map((k) => k.trim()).filter((k) => k.length > 0).filter(Boolean) : [input];
      if (keywords.length > 0) {
        const selectedKeyword = keywords[Math.floor(Math.random() * keywords.length)];
        const provider = this.getActiveApiProvider();
        const apiKey = provider === "pexels" ? this.settings.pexelsApiKey : provider === "pixabay" ? this.settings.pixabayApiKey : provider === "flickr" ? this.settings.flickrApiKey : provider === "unsplash" ? this.settings.unsplashApiKey : null;
        if (!apiKey) {
          return null;
        }
        if (provider === "pexels") {
          return this.fetchPexelsImage(selectedKeyword);
        } else if (provider === "pixabay") {
          return this.fetchPixabayImage(selectedKeyword);
        } else if (provider === "flickr") {
          return this.fetchFlickrImage(selectedKeyword);
        } else if (provider === "unsplash") {
          return this.fetchUnsplashImage(selectedKeyword);
        }
      }
      return null;
    }
    return null;
  }
  async fetchPexelsImage(keyword) {
    const apiKey = this.settings.pexelsApiKey;
    if (!apiKey) {
      return null;
    }
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const fallbackKeyword = defaultKeywords[Math.floor(Math.random() * defaultKeywords.length)];
    const keywords = [keyword, fallbackKeyword];
    for (const currentKeyword of keywords) {
      try {
        const response = await (0, import_obsidian3.requestUrl)({
          url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(currentKeyword)}&per_page=${this.settings.numberOfImages}&size=${this.settings.imageSize}&orientation=${this.settings.imageOrientation}`,
          method: "GET",
          headers: {
            "Authorization": apiKey
          }
        });
        if (response.status !== 200) {
          console.error("Failed to fetch images:", response.status, response.text);
          continue;
        }
        const data = response.json;
        if (data.photos && data.photos.length > 0) {
          const randomIndex = Math.floor(Math.random() * data.photos.length);
          if (currentKeyword !== keyword) {
            console.log(`No image found for "${keyword}". Using image for "${currentKeyword}" instead.`);
          }
          const imageUrl = data.photos[randomIndex].src[this.settings.imageSize];
          try {
            await this.preloadImage(imageUrl);
          } catch (error) {
            console.error(`Failed to preload image: ${error.message}`);
          }
          return imageUrl;
        } else if (currentKeyword === keyword) {
          console.log(`No image found for the provided keyword: "${keyword}". Trying a random default keyword.`);
        }
      } catch (error) {
        console.error(`Error fetching image from API for keyword "${currentKeyword}":`, error);
        new import_obsidian3.Notice(`Failed to fetch image: ${error.message}`);
      }
    }
    console.error("No images found for any keywords, including the random default.");
    return null;
  }
  async fetchPixabayImage(keyword) {
    const apiKey = this.settings.pixabayApiKey;
    if (!apiKey) {
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      const apiUrl = "https://pixabay.com/api/";
      const params = new URLSearchParams({
        key: apiKey,
        q: encodeURIComponent(currentKeyword),
        image_type: "photo",
        per_page: this.settings.numberOfImages,
        safesearch: true
      });
      try {
        const response = await this.makeRequest(`${apiUrl}?${params}`);
        if (response.status !== 200) {
          console.error(`Pixabay API error: ${response.status} ${response.statusText}`);
          continue;
        }
        let data;
        if (response.arrayBuffer) {
          const text = new TextDecoder().decode(response.arrayBuffer);
          try {
            data = JSON.parse(text);
          } catch (error) {
            console.error("Failed to parse Pixabay response:", error);
            continue;
          }
        } else {
          console.error("Unexpected response format:", response);
          continue;
        }
        if (data.hits && data.hits.length > 0) {
          const imageUrls = data.hits.map((hit) => hit.largeImageURL);
          if (imageUrls.length > 0) {
            const randomIndex = Math.floor(Math.random() * imageUrls.length);
            const selectedImageUrl = imageUrls[randomIndex];
            return selectedImageUrl;
          }
        }
        console.log(`No images found for keyword: ${currentKeyword}`);
      } catch (error) {
        console.error("Error fetching image from Pixabay:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts, try a different keyword and/or update the backup keyword list in settings.");
    return null;
  }
  async fetchFlickrImage(keyword) {
    const apiKey = this.settings.flickrApiKey;
    if (!apiKey) {
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      try {
        const searchUrl = `https://www.flickr.com/services/rest/?method=flickr.photos.search&api_key=${apiKey}&text=${encodeURIComponent(currentKeyword)}&per_page=${this.settings.numberOfImages}&format=json&nojsoncallback=1&sort=relevance&content_type=1&media=photos&safe_search=1`;
        const response = await this.makeRequest(searchUrl);
        if (response.status !== 200) {
          console.error(`Flickr API error: ${response.status} ${response.statusText}`);
          continue;
        }
        const data = JSON.parse(new TextDecoder().decode(response.arrayBuffer));
        if (data.stat !== "ok") {
          console.error("Flickr API error:", data);
          continue;
        }
        if (data.photos && data.photos.photo && data.photos.photo.length > 0) {
          const photos = data.photos.photo;
          const randomIndex = Math.floor(Math.random() * photos.length);
          const photo = photos[randomIndex];
          let size = "z";
          switch (this.settings.imageSize) {
            case "small":
              size = "n";
              break;
            // Small 320
            case "medium":
              size = "z";
              break;
            // Medium 640
            case "large":
              size = "b";
              break;
          }
          const imageUrl = `https://live.staticflickr.com/${photo.server}/${photo.id}_${photo.secret}_${size}.jpg`;
          return imageUrl;
        }
        console.log(`No images found for keyword: ${currentKeyword}`);
      } catch (error) {
        console.error("Error fetching image from Flickr:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts");
    return null;
  }
  async fetchUnsplashImage(keyword) {
    const apiKey = this.settings.unsplashApiKey;
    if (!apiKey) {
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      try {
        let apiUrl = "https://api.unsplash.com/search/photos";
        const params = new URLSearchParams({
          query: currentKeyword,
          per_page: this.settings.numberOfImages,
          orientation: this.settings.imageOrientation
        });
        const response = await this.makeRequest(`${apiUrl}?${params}`, {
          headers: {
            "Authorization": `Client-ID ${apiKey}`,
            "Accept-Version": "v1"
          }
        });
        if (response.status !== 200) {
          console.error(`Unsplash API error: ${response.status}`);
          continue;
        }
        const data = JSON.parse(new TextDecoder().decode(response.arrayBuffer));
        if (!data.results || data.results.length === 0) {
          console.log(`No images found for keyword: ${currentKeyword}`);
          continue;
        }
        const randomIndex = Math.floor(Math.random() * data.results.length);
        const photo = data.results[randomIndex];
        let imageUrl;
        switch (this.settings.imageSize) {
          case "small":
            imageUrl = photo.urls.small;
            break;
          case "medium":
            imageUrl = photo.urls.regular;
            break;
          case "large":
            imageUrl = photo.urls.full;
            break;
          default:
            imageUrl = photo.urls.regular;
        }
        return imageUrl;
      } catch (error) {
        console.error("Error fetching image from Unsplash:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts");
    return null;
  }
  async makeRequest(url, options = {}) {
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        headers: options.headers || {},
        ...options
      });
      return response;
    } catch (error) {
      console.error("Request failed:", error);
      throw new Error(`Request failed: ${error.message}`);
    }
  }
  preloadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(url);
      img.onerror = reject;
      img.src = url;
    });
  }
  getInputType(input) {
    if (Array.isArray(input)) {
      input = input.flat()[0];
    }
    if (typeof input !== "string") {
      return "invalid";
    }
    input = input.trim().replace(/^["'](.*)["']$/, "$1");
    if (input.match(/^\[{2}.*\]{2}$/) || input.match(/^"?\[{2}.*\]{2}"?$/)) {
      return "obsidianLink";
    }
    try {
      new URL(input);
      return "url";
    } catch (_) {
      const file = this.app.vault.getAbstractFileByPath(input);
      if (file && "extension" in file) {
        if (file.extension.match(/^(jpg|jpeg|png|gif|bmp|svg)$/i)) {
          return "vaultPath";
        }
      }
      return "keyword";
    }
  }
  getPathFromObsidianLink(link) {
    let cleanLink = link.startsWith("!") ? link.slice(1) : link;
    let innerLink = cleanLink.startsWith("[[") ? cleanLink.slice(2) : cleanLink;
    innerLink = innerLink.endsWith("]]") ? innerLink.slice(0, -2) : innerLink;
    const path = innerLink.split("|")[0];
    return this.app.metadataCache.getFirstLinkpathDest(path, "");
  }
  async getVaultImageUrl(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && "extension" in file) {
      try {
        const arrayBuffer = await this.app.vault.readBinary(file);
        const mimeType = file.extension.toLowerCase() === "svg" ? "image/svg+xml" : `image/${file.extension}`;
        const blob = new Blob([arrayBuffer], { type: mimeType });
        const url = URL.createObjectURL(blob);
        return url;
      } catch (error) {
        console.error("Error reading vault image:", error);
        return null;
      }
    }
    return null;
  }
  updateAllBanners() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === "markdown") {
        this.updateBanner(leaf.view, true);
      }
    });
  }
  async postProcessor(el, ctx) {
    const frontmatter = ctx.frontmatter;
    if (frontmatter && frontmatter[this.settings.customBannerField]) {
      await this.addPixelBanner(el, {
        frontmatter,
        file: ctx.sourcePath,
        isContentChange: false,
        yPosition: frontmatter[this.settings.customYPositionField] || this.settings.yPosition,
        contentStartPosition: frontmatter[this.settings.customContentStartField] || this.settings.contentStartPosition,
        customBannerField: this.settings.customBannerField,
        customYPositionField: this.settings.customYPositionField,
        customContentStartField: this.settings.customContentStartField,
        customImageDisplayField: this.settings.customImageDisplayField,
        customImageRepeatField: this.settings.customImageRepeatField,
        bannerImage: frontmatter[this.settings.customBannerField]
      });
      if (this.settings.hidePixelBannerFields) {
        const frontmatterEl = el.querySelector(".frontmatter");
        if (frontmatterEl) {
          const fieldsToHide = [
            ...this.settings.customBannerField,
            ...this.settings.customYPositionField,
            ...this.settings.customXPositionField,
            ...this.settings.customContentStartField,
            ...this.settings.customImageDisplayField,
            ...this.settings.customImageRepeatField,
            ...this.settings.customBannerHeightField,
            ...this.settings.customFadeField,
            ...this.settings.customBorderRadiusField
          ];
          const rows = frontmatterEl.querySelectorAll(".frontmatter-container .frontmatter-section-label");
          rows.forEach((row) => {
            const label = row.textContent.replace(":", "").trim();
            if (fieldsToHide.includes(label)) {
              row.closest(".frontmatter-section").classList.add("pixel-banner-hidden-field");
            }
          });
        }
      }
    }
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian3.MarkdownView) {
        const viewContent = leaf.view.contentEl;
        if (viewContent._resizeObserver) {
          viewContent._resizeObserver.disconnect();
          delete viewContent._resizeObserver;
        }
      }
    });
    const styleElTitle = document.getElementById("pixel-banner-embedded-titles");
    if (styleElTitle) styleElTitle.remove();
    const styleElBanner = document.getElementById("pixel-banner-embedded-banners");
    if (styleElBanner) styleElBanner.remove();
  }
  applyContentStartPosition(el, contentStartPosition) {
    if (!el) {
      return;
    }
    el.style.setProperty("--pixel-banner-content-start", `${contentStartPosition}px`);
  }
  applyBannerWidth(el) {
    if (!el) return;
    setTimeout(() => {
      const theWidth = el.clientWidth;
      const bannerGap = this.settings.bannerGap;
      el.style.setProperty("--pixel-banner-width", `${theWidth - bannerGap * 2}px`);
      el.style.setProperty("--pixel-banner-banner-gap", `${bannerGap}px`);
    }, 50);
  }
  getFolderSpecificSetting(filePath, settingName) {
    var _a;
    const folderPath = this.getFolderPath(filePath);
    for (const folderImage of this.settings.folderImages) {
      if (folderPath.startsWith(folderImage.folder)) {
        return (_a = folderImage[settingName]) != null ? _a : void 0;
      }
    }
    return void 0;
  }
  async cleanOrphanedPins() {
    var _a;
    const vault = this.app.vault;
    const folderPath = this.settings.pinnedImageFolder;
    let cleaned = 0;
    try {
      if (!await vault.adapter.exists(folderPath)) {
        return { cleaned };
      }
      const pinnedFolder = vault.getAbstractFileByPath(folderPath);
      if (!pinnedFolder || !pinnedFolder.children) {
        return { cleaned };
      }
      const imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "webp", "svg"];
      const pinnedImages = pinnedFolder.children.filter((file) => imageExtensions.includes(file.extension.toLowerCase())).map((file) => file.path);
      if (!pinnedImages.length) {
        return { cleaned };
      }
      const markdownFiles = this.app.vault.getMarkdownFiles();
      const bannerFields = this.settings.customBannerField;
      const referencedImages = /* @__PURE__ */ new Set();
      for (const file of markdownFiles) {
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if (frontmatter) {
          for (const field of bannerFields) {
            const bannerValue = frontmatter[field];
            if (bannerValue && typeof bannerValue === "string") {
              let cleanPath;
              if (bannerValue.startsWith("[[") && bannerValue.endsWith("]]")) {
                cleanPath = bannerValue.slice(2, -2).replace(/["']/g, "");
              } else {
                cleanPath = bannerValue.replace(/["']/g, "");
              }
              if (!cleanPath.startsWith(folderPath)) {
                const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(cleanPath, file.path);
                if (resolvedFile) {
                  cleanPath = resolvedFile.path;
                }
              }
              referencedImages.add(cleanPath);
            }
          }
        }
      }
      for (const imagePath of pinnedImages) {
        if (!referencedImages.has(imagePath)) {
          await vault.trash(vault.getAbstractFileByPath(imagePath), true);
          cleaned++;
        }
      }
      return { cleaned };
    } catch (error) {
      console.error("Error in cleanOrphanedPins:", error);
      throw error;
    }
  }
  async checkVersion() {
    const currentVersion = this.manifest.version;
    const lastVersion = this.settings.lastVersion;
    if (this.settings.showReleaseNotes && (!lastVersion || lastVersion !== currentVersion)) {
      const releaseNotes2 = await this.getReleaseNotes(currentVersion);
      new ReleaseNotesModal(this.app, currentVersion, releaseNotes2).open();
      this.settings.lastVersion = currentVersion;
      await this.saveSettings();
    }
  }
  async getReleaseNotes(version) {
    return releaseNotes;
  }
  async addPixelBanner(el, ctx) {
    var _a, _b, _c, _d;
    const { frontmatter, file, isContentChange, yPosition, xPosition, contentStartPosition, bannerImage, isReadingView } = ctx;
    const viewContent = el;
    const isEmbedded = viewContent.classList.contains("internal-embed") && viewContent.classList.contains("markdown-embed");
    if (!isEmbedded) {
      viewContent.classList.add("pixel-banner");
    }
    let container;
    if (isEmbedded) {
      container = viewContent.querySelector(".markdown-preview-sizer");
      if (!container) {
        container = viewContent.querySelector(".markdown-embed-content");
      }
      if (!container) {
        container = viewContent;
      }
    } else {
      container = isReadingView ? viewContent.querySelector(".markdown-preview-sizer:not(.internal-embed .markdown-preview-sizer)") : viewContent.querySelector(".cm-sizer");
      if (!viewContent._resizeObserver) {
        const debouncedResize = debounce(() => {
          this.applyBannerWidth(viewContent);
        }, 100);
        viewContent._resizeObserver = new ResizeObserver(debouncedResize);
        viewContent._resizeObserver.observe(viewContent);
      }
    }
    if (!container) {
      return;
    }
    let bannerDiv = container.querySelector(":scope > .pixel-banner-image");
    let pinIcon = container.querySelector(":scope > .pin-icon");
    if (!bannerDiv) {
      bannerDiv = createDiv({ cls: "pixel-banner-image" });
      container.insertBefore(bannerDiv, container.firstChild);
      bannerDiv._isPersistentBanner = true;
    }
    if (!isEmbedded) {
      const existingViewIcon = container.querySelector(".view-image-icon");
      const existingPinIcon = container.querySelector(".pin-icon");
      const existingRefreshIcon = container.querySelector(".refresh-icon");
      const existingSelectIcon = container.querySelector(".select-image-icon");
      if (existingViewIcon) existingViewIcon.remove();
      if (existingPinIcon) existingPinIcon.remove();
      if (existingRefreshIcon) existingRefreshIcon.remove();
      if (existingSelectIcon) existingSelectIcon.remove();
      let leftOffset = this.settings.bannerGap + 5;
      if (this.settings.showSelectImageIcon) {
        const selectImageIcon = createDiv({ cls: "select-image-icon" });
        selectImageIcon.style.position = "absolute";
        selectImageIcon.style.top = "10px";
        selectImageIcon.style.left = `${leftOffset}px`;
        selectImageIcon.style.fontSize = "1.5em";
        selectImageIcon.style.cursor = "pointer";
        selectImageIcon.innerHTML = "\u{1F3F7}\uFE0F";
        selectImageIcon._isPersistentSelectImage = true;
        selectImageIcon.onclick = () => this.handleSelectImage();
        container.appendChild(selectImageIcon);
        leftOffset += 35;
      }
      if (this.settings.showViewImageIcon) {
        const viewImageIcon = createDiv({ cls: "view-image-icon" });
        viewImageIcon.style.position = "absolute";
        viewImageIcon.style.top = "10px";
        viewImageIcon.style.left = `${leftOffset}px`;
        viewImageIcon.style.fontSize = "1.5em";
        viewImageIcon.style.cursor = "pointer";
        viewImageIcon.innerHTML = "\u{1F5BC}\uFE0F";
        viewImageIcon._isPersistentViewImage = true;
        viewImageIcon.style.display = "none";
        container.appendChild(viewImageIcon);
        leftOffset += 35;
        const updateViewIcon = (imageUrl2) => {
          if (imageUrl2) {
            viewImageIcon.style.display = "block";
            viewImageIcon.onclick = () => {
              new ImageViewModal(this.app, imageUrl2).open();
            };
          } else {
            viewImageIcon.style.display = "none";
          }
        };
        viewImageIcon._updateVisibility = updateViewIcon;
      }
      const imageUrl = this.loadedImages.get(file.path);
      const inputType = this.getInputType(bannerImage);
      const canPin = imageUrl && (inputType === "keyword" || inputType === "url") && this.settings.showPinIcon;
      if (canPin) {
        const pinIcon2 = createDiv({ cls: "pin-icon" });
        pinIcon2.style.position = "absolute";
        pinIcon2.style.top = "10px";
        pinIcon2.style.left = `${leftOffset}px`;
        pinIcon2.style.fontSize = "1.5em";
        pinIcon2.style.cursor = "pointer";
        pinIcon2.innerHTML = "\u{1F4CC}";
        pinIcon2._isPersistentPin = true;
        pinIcon2.onclick = async () => {
          try {
            await handlePinIconClick(imageUrl, this);
          } catch (error) {
            console.error("Error pinning image:", error);
            new import_obsidian3.Notice("Failed to pin the image.");
          }
        };
        container.appendChild(pinIcon2);
        leftOffset += 35;
        if (this.settings.showRefreshIcon) {
          const refreshIcon = createDiv({ cls: "refresh-icon" });
          refreshIcon.style.position = "absolute";
          refreshIcon.style.top = "10px";
          refreshIcon.style.left = `${leftOffset}px`;
          refreshIcon.style.fontSize = "1.5em";
          refreshIcon.style.cursor = "pointer";
          refreshIcon.innerHTML = "\u{1F504}";
          refreshIcon._isPersistentRefresh = true;
          container.appendChild(refreshIcon);
        }
      }
    } else {
      this.updateEmbeddedBannersVisibility();
    }
    if (!container._hasOverriddenSetChildrenInPlace) {
      const originalSetChildrenInPlace = container.setChildrenInPlace;
      container.setChildrenInPlace = function(children) {
        const bannerElement = this.querySelector(":scope > .pixel-banner-image");
        const viewImageElement = this.querySelector(":scope > .view-image-icon");
        const pinElement = this.querySelector(":scope > .pin-icon");
        const refreshElement = this.querySelector(":scope > .refresh-icon");
        const selectImageElement = this.querySelector(":scope > .select-image-icon");
        children = Array.from(children).filter(
          (child) => {
            var _a2, _b2, _c2, _d2, _e;
            return !((_a2 = child.classList) == null ? void 0 : _a2.contains("pixel-banner-image")) && !((_b2 = child.classList) == null ? void 0 : _b2.contains("view-image-icon")) && !((_c2 = child.classList) == null ? void 0 : _c2.contains("pin-icon")) && !((_d2 = child.classList) == null ? void 0 : _d2.contains("refresh-icon")) && !((_e = child.classList) == null ? void 0 : _e.contains("select-image-icon"));
          }
        );
        if (bannerElement == null ? void 0 : bannerElement._isPersistentBanner) {
          children.unshift(bannerElement);
        }
        if (selectImageElement == null ? void 0 : selectImageElement._isPersistentSelectImage) {
          children.push(selectImageElement);
        }
        if (viewImageElement == null ? void 0 : viewImageElement._isPersistentViewImage) {
          children.push(viewImageElement);
        }
        if (pinElement == null ? void 0 : pinElement._isPersistentPin) {
          children.push(pinElement);
        }
        if (refreshElement == null ? void 0 : refreshElement._isPersistentRefresh) {
          children.push(refreshElement);
        }
        return originalSetChildrenInPlace.call(this, children);
      };
      container._hasOverriddenSetChildrenInPlace = true;
    }
    if (bannerImage) {
      let imageUrl = this.loadedImages.get(file.path);
      const lastInput = this.lastKeywords.get(file.path);
      const inputType = this.getInputType(bannerImage);
      if (!imageUrl || isContentChange && bannerImage !== lastInput) {
        imageUrl = await this.getImageUrl(inputType, bannerImage);
        if (imageUrl) {
          this.loadedImages.set(file.path, imageUrl);
          this.lastKeywords.set(file.path, bannerImage);
        }
      }
      if (imageUrl) {
        const frontmatterYPosition = getFrontmatterValue(frontmatter, this.settings.customYPositionField);
        const folderSpecific = this.getFolderSpecificImage(file.path);
        const effectiveYPosition = (_a = frontmatterYPosition != null ? frontmatterYPosition : folderSpecific == null ? void 0 : folderSpecific.yPosition) != null ? _a : this.settings.yPosition;
        const frontmatterXPosition = getFrontmatterValue(frontmatter, this.settings.customXPositionField);
        const effectiveXPosition = (_b = frontmatterXPosition != null ? frontmatterXPosition : folderSpecific == null ? void 0 : folderSpecific.xPosition) != null ? _b : this.settings.xPosition;
        const imageDisplay = getFrontmatterValue(frontmatter, this.settings.customImageDisplayField) || (folderSpecific == null ? void 0 : folderSpecific.imageDisplay) || this.settings.imageDisplay;
        const isSvg = imageUrl.includes("image/svg+xml") || file.path && file.path.toLowerCase().endsWith(".svg");
        bannerDiv.style.backgroundImage = `url('${imageUrl}')`;
        bannerDiv.style.backgroundPosition = `${effectiveXPosition}% ${effectiveYPosition}%`;
        if (isSvg) {
          bannerDiv.style.backgroundSize = imageDisplay === "contain" ? "contain" : "100% 100%";
        } else {
          bannerDiv.style.backgroundSize = imageDisplay || "cover";
        }
        bannerDiv.style.display = "block";
        const viewImageIcon = container.querySelector(":scope > .view-image-icon");
        if (viewImageIcon && viewImageIcon._updateVisibility) {
          viewImageIcon._updateVisibility(imageUrl);
        }
        this.applyBannerSettings(bannerDiv, ctx);
        const frontmatterContentStart = getFrontmatterValue(frontmatter, this.settings.customContentStartField);
        const parsedFrontmatterStart = frontmatterContentStart ? Number(frontmatterContentStart) : null;
        const effectiveContentStart = (_d = (_c = parsedFrontmatterStart != null ? parsedFrontmatterStart : contentStartPosition) != null ? _c : folderSpecific == null ? void 0 : folderSpecific.contentStartPosition) != null ? _d : this.settings.contentStartPosition;
        this.applyContentStartPosition(viewContent, effectiveContentStart);
        this.applyBannerWidth(viewContent);
        if (!isEmbedded && (inputType === "keyword" || inputType === "url") && this.settings.showPinIcon) {
          const refreshIcon = container.querySelector(":scope > .refresh-icon");
          if (refreshIcon && inputType === "keyword" && this.settings.showRefreshIcon) {
            refreshIcon.style.display = "block";
            refreshIcon.onclick = async () => {
              try {
                this.loadedImages.delete(file.path);
                this.lastKeywords.delete(file.path);
                const newImageUrl = await this.getImageUrl(inputType, bannerImage);
                if (newImageUrl) {
                  this.loadedImages.set(file.path, newImageUrl);
                  this.lastKeywords.set(file.path, bannerImage);
                  bannerDiv.style.backgroundImage = `url('${newImageUrl}')`;
                  const viewImageIcon2 = container.querySelector(":scope > .view-image-icon");
                  if (viewImageIcon2 && viewImageIcon2._updateVisibility) {
                    viewImageIcon2._updateVisibility(newImageUrl);
                  }
                  const pinIcon2 = container.querySelector(":scope > .pin-icon");
                  if (pinIcon2) {
                    pinIcon2.onclick = async () => {
                      try {
                        await handlePinIconClick(newImageUrl, this);
                      } catch (error) {
                        console.error("Error pinning image:", error);
                        new import_obsidian3.Notice("Failed to pin the image.");
                      }
                    };
                  }
                  new import_obsidian3.Notice("\u{1F504} Refreshed banner image");
                }
              } catch (error) {
                console.error("Error refreshing image:", error);
                new import_obsidian3.Notice("Failed to refresh image");
              }
            };
          } else if (refreshIcon) {
            refreshIcon.style.display = "none";
          }
        } else {
          if (pinIcon) pinIcon.style.display = "none";
          const refreshIcon = container.querySelector(":scope > .refresh-icon");
          if (refreshIcon) refreshIcon.style.display = "none";
        }
      } else {
        bannerDiv.style.display = "none";
        if (pinIcon) pinIcon.style.display = "none";
        const refreshIcon = container.querySelector(":scope > .refresh-icon");
        if (refreshIcon) refreshIcon.style.display = "none";
        const viewImageIcon = container.querySelector(":scope > .view-image-icon");
        if (viewImageIcon && viewImageIcon._updateVisibility) {
          viewImageIcon._updateVisibility(null);
        }
        this.loadedImages.delete(file.path);
        this.lastKeywords.delete(file.path);
        if (!isEmbedded) {
          viewContent.classList.remove("pixel-banner");
        }
      }
    }
  }
  applyBannerSettings(bannerDiv, ctx) {
    const { frontmatter, imageDisplay, imageRepeat, bannerHeight, fade, borderRadius } = ctx;
    const folderSpecific = this.getFolderSpecificImage(ctx.file.path);
    const titleColor = getFrontmatterValue(frontmatter, this.settings.customTitleColorField) || (folderSpecific == null ? void 0 : folderSpecific.titleColor) || this.settings.titleColor;
    bannerDiv.style.backgroundSize = imageDisplay || "cover";
    bannerDiv.style.backgroundRepeat = imageRepeat ? "repeat" : "no-repeat";
    bannerDiv.style.setProperty("--pixel-banner-height", `${bannerHeight}px`);
    bannerDiv.style.setProperty("--pixel-banner-fade", `${fade}%`);
    bannerDiv.style.setProperty("--pixel-banner-radius", `${borderRadius}px`);
    const container = bannerDiv.closest(".markdown-preview-view, .markdown-source-view");
    if (container) {
      container.style.setProperty("--pixel-banner-title-color", titleColor);
    }
  }
  // Add this helper method to randomly select an API provider
  getActiveApiProvider() {
    if (this.settings.apiProvider !== "all") {
      return this.settings.apiProvider;
    }
    const availableProviders = [];
    if (this.settings.pexelsApiKey) availableProviders.push("pexels");
    if (this.settings.pixabayApiKey) availableProviders.push("pixabay");
    if (this.settings.flickrApiKey) availableProviders.push("flickr");
    if (this.settings.unsplashApiKey) availableProviders.push("unsplash");
    if (availableProviders.length === 0) {
      return "pexels";
    }
    return availableProviders[Math.floor(Math.random() * availableProviders.length)];
  }
  // Add this new method to handle field visibility
  updateFieldVisibility(view) {
    if (!view || view.getMode() !== "preview") return;
    const fieldsToHide = [
      ...this.settings.customBannerField,
      ...this.settings.customYPositionField,
      ...this.settings.customXPositionField,
      ...this.settings.customContentStartField,
      ...this.settings.customImageDisplayField,
      ...this.settings.customImageRepeatField,
      ...this.settings.customBannerHeightField,
      ...this.settings.customFadeField,
      ...this.settings.customBorderRadiusField,
      ...this.settings.customTitleColorField,
      ...this.settings.customBannerShuffleField
    ];
    const propertiesContainer = view.contentEl.querySelector(".metadata-container");
    if (!propertiesContainer) return;
    const propertyElements = propertiesContainer.querySelectorAll(".metadata-property");
    let visiblePropertiesCount = 0;
    let bannerPropertiesCount = 0;
    propertyElements.forEach((propertyEl) => {
      const key = propertyEl.getAttribute("data-property-key");
      if (fieldsToHide.includes(key)) {
        propertyEl.classList.add("pixel-banner-hidden-field");
        bannerPropertiesCount++;
      } else {
        visiblePropertiesCount++;
      }
    });
    if (this.settings.hidePropertiesSectionIfOnlyBanner && this.settings.hidePixelBannerFields && visiblePropertiesCount === 0 && bannerPropertiesCount > 0) {
      propertiesContainer.classList.add("pixel-banner-hidden-section");
    } else {
      propertiesContainer.classList.remove("pixel-banner-hidden-section");
    }
  }
  // get random image from folder
  getRandomImageFromFolder(folderPath) {
    try {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder || !folder.children) return null;
      const imageFiles = folder.children.filter(
        (file) => file.extension && ["png", "jpg", "jpeg", "gif", "webp", "svg"].includes(file.extension.toLowerCase())
      );
      if (imageFiles.length === 0) return null;
      const randomImage = imageFiles[Math.floor(Math.random() * imageFiles.length)];
      return randomImage.path;
    } catch (error) {
      console.error("Error getting random image:", error);
      return null;
    }
  }
  updateEmbeddedTitlesVisibility() {
    const styleId = "pixel-banner-embedded-titles";
    let styleEl = document.getElementById(styleId);
    if (this.settings.hideEmbeddedNoteTitles) {
      if (!styleEl) {
        styleEl = document.createElement("style");
        styleEl.id = styleId;
        document.head.appendChild(styleEl);
      }
      styleEl.textContent = ".embed-title.markdown-embed-title { display: none !important; }";
    } else if (styleEl) {
      styleEl.remove();
    }
  }
  updateEmbeddedBannersVisibility() {
    const styleId = "pixel-banner-embedded-banners";
    let styleEl = document.getElementById(styleId);
    if (this.settings.hideEmbeddedNoteBanners) {
      if (!styleEl) {
        styleEl = document.createElement("style");
        styleEl.id = styleId;
        document.head.appendChild(styleEl);
      }
      styleEl.textContent = `
                .internal-embed .pixel-banner-image {
                    display: none !important;
                }
                .internal-embed > .markdown-embed-content .cm-sizer:first-of-type,
                .internal-embed > .markdown-embed-content .markdown-preview-sizer:first-of-type {
                    padding-top: unset !important;
                }
            `;
    } else if (styleEl) {
      styleEl.remove();
    }
  }
  async handleSelectImage() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice("No active file");
      return;
    }
    new ImageSelectionModal(
      this.app,
      this,
      async (selectedFile) => {
        let imageReference = selectedFile.path;
        if (this.settings.useShortPath) {
          const allFiles = this.app.vault.getFiles();
          const matchingFiles = allFiles.filter((f) => f.name === selectedFile.name);
          imageReference = matchingFiles.length === 1 ? selectedFile.name : selectedFile.path;
        }
        let fileContent = await this.app.vault.read(activeFile);
        const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
        const hasFrontmatter = frontmatterRegex.test(fileContent);
        const bannerField = Array.isArray(this.settings.customBannerField) && this.settings.customBannerField.length > 0 ? this.settings.customBannerField[0] : "banner";
        fileContent = fileContent.replace(/^\s+/, "");
        let updatedContent;
        if (hasFrontmatter) {
          updatedContent = fileContent.replace(frontmatterRegex, (match, frontmatter) => {
            const bannerRegex = new RegExp(`${bannerField}:\\s*.+`);
            let cleanedFrontmatter = frontmatter.trim();
            this.settings.customBannerField.forEach((field) => {
              const fieldRegex = new RegExp(`${field}:\\s*.+\\n?`, "g");
              cleanedFrontmatter = cleanedFrontmatter.replace(fieldRegex, "");
            });
            cleanedFrontmatter = cleanedFrontmatter.trim();
            const newFrontmatter = `${bannerField}: "[[${imageReference}]]"${cleanedFrontmatter ? "\n" + cleanedFrontmatter : ""}`;
            return `---
${newFrontmatter}
---`;
          });
        } else {
          const cleanContent = fileContent.replace(/^\s+/, "");
          updatedContent = `---
${bannerField}: "[[${imageReference}]]"
---

${cleanContent}`;
        }
        updatedContent = updatedContent.replace(/^\s+/, "");
        if (updatedContent !== fileContent) {
          await this.app.vault.modify(activeFile, updatedContent);
          if (this.settings.useShortPath && imageReference === selectedFile.path) {
            new import_obsidian3.Notice("Banner image updated (full path used due to duplicate filenames)");
          } else {
            new import_obsidian3.Notice("Banner image updated");
          }
        }
      },
      this.settings.defaultSelectImagePath
    ).open();
  }
};
async function handlePinIconClick(imageUrl, plugin, usedField = null) {
  const imageBlob = await fetchImage(imageUrl);
  const { initialPath, file } = await saveImageLocally(imageBlob, plugin);
  const finalPath = await waitForFileRename(file, plugin);
  if (!finalPath) {
    console.error("\u274C Failed to resolve valid file path");
    new import_obsidian3.Notice("Failed to save image - file not found");
    return;
  }
  await updateNoteFrontmatter(finalPath, plugin, usedField);
  hidePinIcon();
}
async function fetchImage(url) {
  const response = await fetch(url);
  if (!response.ok) throw new Error("Image download failed");
  return await response.arrayBuffer();
}
var FolderSelectionModal2 = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app2, defaultFolder, onChoose) {
    super(app2);
    this.defaultFolder = defaultFolder;
    this.onChoose = onChoose;
    this.setPlaceholder("Select or type folder path to save Pinned Banner Image");
    this.titleEl.setText("Choose Folder to save Pinned Banner Image");
  }
  getItems() {
    return [this.defaultFolder, ...this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path)];
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
  onOpen() {
    super.onOpen();
    const inputEl = this.inputEl;
    inputEl.value = this.defaultFolder;
    inputEl.select();
    this.updateSuggestions();
  }
};
async function saveImageLocally(arrayBuffer, plugin) {
  const vault = plugin.app.vault;
  const defaultFolderPath = plugin.settings.pinnedImageFolder;
  const folderPath = await new Promise((resolve) => {
    const modal = new FolderSelectionModal2(plugin.app, defaultFolderPath, (result) => {
      resolve(result);
    });
    modal.open();
  });
  if (!folderPath) {
    throw new Error("No folder selected");
  }
  if (!await vault.adapter.exists(folderPath)) {
    await vault.createFolder(folderPath);
  }
  const suggestedName = "pixel-banner-image";
  const userInput = await new Promise((resolve) => {
    const modal = new SaveImageModal2(plugin.app, suggestedName, (result) => {
      resolve(result);
    });
    modal.open();
  });
  if (!userInput) {
    throw new Error("No filename provided");
  }
  let baseName = userInput.replace(/[^a-zA-Z0-9-_ ]/g, "").trim();
  if (!baseName) baseName = "banner";
  if (!baseName.toLowerCase().endsWith(".png")) baseName += ".png";
  let fileName = baseName;
  let counter = 1;
  while (await vault.adapter.exists(`${folderPath}/${fileName}`)) {
    const nameWithoutExt = baseName.slice(0, -4);
    fileName = `${nameWithoutExt}-${counter}.png`;
    counter++;
  }
  const filePath = `${folderPath}/${fileName}`;
  const savedFile = await vault.createBinary(filePath, arrayBuffer);
  return {
    initialPath: filePath,
    file: savedFile
  };
}
async function updateNoteFrontmatter(imagePath, plugin, usedField = null) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) return;
  let imageReference = imagePath;
  if (plugin.settings.useShortPath) {
    const imageFile = plugin.app.vault.getAbstractFileByPath(imagePath);
    if (imageFile) {
      const allFiles = plugin.app.vault.getFiles();
      const matchingFiles = allFiles.filter((f) => f.name === imageFile.name);
      imageReference = matchingFiles.length === 1 ? imageFile.name : imageFile.path;
    }
  }
  let fileContent = await app.vault.read(activeFile);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const hasFrontmatter = frontmatterRegex.test(fileContent);
  const bannerField = usedField || (Array.isArray(plugin.settings.customBannerField) && plugin.settings.customBannerField.length > 0 ? plugin.settings.customBannerField[0] : "banner");
  fileContent = fileContent.replace(/^\s+/, "");
  let updatedContent;
  if (hasFrontmatter) {
    updatedContent = fileContent.replace(frontmatterRegex, (match, frontmatter) => {
      const bannerRegex = new RegExp(`${bannerField}:\\s*.+`);
      let cleanedFrontmatter = frontmatter.trim();
      plugin.settings.customBannerField.forEach((field) => {
        const fieldRegex = new RegExp(`${field}:\\s*.+\\n?`, "g");
        cleanedFrontmatter = cleanedFrontmatter.replace(fieldRegex, "");
      });
      cleanedFrontmatter = cleanedFrontmatter.trim();
      const newFrontmatter = `${bannerField}: "[[${imageReference}]]"${cleanedFrontmatter ? "\n" + cleanedFrontmatter : ""}`;
      return `---
${newFrontmatter}
---`;
    });
  } else {
    const cleanContent = fileContent.replace(/^\s+/, "");
    updatedContent = `---
${bannerField}: "[[${imageReference}]]"
---

${cleanContent}`;
  }
  updatedContent = updatedContent.replace(/^\s+/, "");
  if (updatedContent !== fileContent) {
    await app.vault.modify(activeFile, updatedContent);
    if (plugin.settings.useShortPath && imageReference === imagePath) {
      new import_obsidian3.Notice("Banner image pinned (full path used due to duplicate filenames)");
    } else {
      new import_obsidian3.Notice("Banner image pinned");
    }
  }
}
function hidePinIcon() {
  const pinIcon = document.querySelector(".pin-icon");
  if (pinIcon) pinIcon.style.display = "none";
}
var SaveImageModal2 = class extends import_obsidian3.Modal {
  constructor(app2, suggestedName, onSubmit) {
    super(app2);
    this.suggestedName = suggestedName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save Banner Image" });
    const inputContainer = contentEl.createDiv();
    inputContainer.style.margin = "1em 0";
    const input = inputContainer.createEl("input", {
      type: "text",
      value: this.suggestedName
    });
    input.style.width = "100%";
    input.focus();
    input.select();
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "1em";
    buttonContainer.style.marginTop = "1em";
    const submitButton = buttonContainer.createEl("button", {
      text: "Save"
    });
    submitButton.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.onSubmit(input.value);
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.onSubmit(null);
      this.close();
    });
    input.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        event.stopPropagation();
        setTimeout(() => {
          this.onSubmit(input.value);
          this.close();
        }, 0);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function waitForFileRename(file, plugin) {
  return new Promise((resolve) => {
    const initialPath = file.path;
    let timeoutId;
    let renamedPath = null;
    const validatePath = async (path) => {
      if (!path) return false;
      return await plugin.app.vault.adapter.exists(path);
    };
    const handleRename = async (theFile) => {
      if (theFile == null ? void 0 : theFile.path) {
        renamedPath = theFile == null ? void 0 : theFile.path;
      }
    };
    const cleanup = () => {
      plugin.app.vault.off("rename", handleRename);
    };
    plugin.app.vault.on("rename", handleRename);
    timeoutId = setTimeout(async () => {
      cleanup();
      if (renamedPath) {
        const exists = await validatePath(renamedPath);
        if (exists) {
          return resolve(renamedPath);
        }
      }
      const initialExists = await validatePath(initialPath);
      if (initialExists) {
        return resolve(initialPath);
      }
      resolve(null);
    }, 1500);
  });
}

/* nosourcemap */